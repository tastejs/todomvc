/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {'use strict'

	__webpack_require__(2)

	const nx = {
	  component: __webpack_require__(4),
	  middlewares: __webpack_require__(12),
	  components: __webpack_require__(32),
	  filters: __webpack_require__(35),
	  limiters: __webpack_require__(45),
	  observer: __webpack_require__(30),
	  compiler: __webpack_require__(15)
	}

	for (let name in nx.filters) {
	  nx.middlewares.expression.filter(name, nx.filters[name])
	}

	for (let name in nx.limiters) {
	  nx.middlewares.code.limiter(name, nx.limiters[name])
	}

	if (module && module.exports) {
	  module.exports = nx
	}
	if (window) {
	  window.nx = nx
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ },
/* 1 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	__webpack_require__(3)


/***/ },
/* 3 */
/***/ function(module, exports) {

	'use strict'

	const secret = {
	  registered: Symbol('registered')
	}

	if (!document.registerElement) {
	  const registry = new Map()

	  const observer = new MutationObserver(onMutations)
	  observer.observe(document, {childList: true, subtree: true})

	  function onMutations (mutations) {
	    for (let mutation of mutations) {
	      Array.prototype.forEach.call(mutation.addedNodes, onNodeAdded)
	      Array.prototype.forEach.call(mutation.removedNodes, onNodeRemoved)
	    }
	    mutations = observer.takeRecords()
	    if (mutations.length) {
	      onMutations(mutations)
	    }
	  }

	  function onNodeAdded (node) {
	    if (!(node instanceof Element)) return

	    let config = registry.get(node.getAttribute('is'))
	    if (!config || config.extends !== node.tagName.toLowerCase()) {
	      config = registry.get(node.tagName.toLowerCase())
	    }
	    if (config && !node[secret.registered]) {
	      Object.assign(node, config.prototype)
	      node[secret.registered] = true
	    }
	    if (node[secret.registered] && node.attachedCallback) {
	      node.attachedCallback()
	    }
	    Array.prototype.forEach.call(node.childNodes, onNodeAdded)
	  }

	  function onNodeRemoved (node) {
	    if (node[secret.registered] && node.detachedCallback) {
	      node.detachedCallback()
	    }
	    Array.prototype.forEach.call(node.childNodes, onNodeRemoved)
	  }

	  document.registerElement = function registerElement (name, config) {
	    name = name.toLowerCase()
	    if (config.extends) {
	      config.extends = config.extends.toLowerCase()
	    }
	    registry.set(name, config)

	    if (config.extends) {
	      Array.prototype.forEach.call(document.querySelectorAll(`[is=${name}]`), onNodeAdded)
	    } else {
	      Array.prototype.forEach.call(document.getElementsByTagName(name), onNodeAdded)
	    }
	  }

	  const originalCreateElement = document.createElement
	  document.createElement = function createElement (name, is) {
	    const element = originalCreateElement.call(document, name)
	    if (is) {
	      element.setAttribute('is', is)
	    }
	    return element
	  }
	}


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	module.exports = __webpack_require__(5)


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	const validateConfig = __webpack_require__(6)
	const validateMiddlewares = __webpack_require__(7)
	const getContext = __webpack_require__(8)
	const onNodeAdded = __webpack_require__(9)
	const onNodeRemoved = __webpack_require__(11)

	const secret = {
	  config: Symbol('component config'),
	  contentWatcher: Symbol('content watcher')
	}
	const contentWatcherConfig = {
	  childList: true,
	  subtree: true
	}
	const addedNodeContext = {}
	const addedNodes = new Set()

	module.exports = function component (rawConfig) {
	  return {use, useOnContent, register, [secret.config]: validateConfig(rawConfig)}
	}

	function use (middleware) {
	  if (typeof middleware !== 'function') {
	    throw new TypeError('first argument must be a function')
	  }
	  const config = this[secret.config]
	  config.middlewares = config.middlewares || []
	  config.middlewares.push(middleware)
	  return this
	}

	function useOnContent (contentMiddleware) {
	  if (typeof contentMiddleware !== 'function') {
	    throw new TypeError('first argument must be a function')
	  }
	  const config = this[secret.config]
	  if (config.isolate === true) {
	    throw new Error('content middlewares can not be added to isolated components')
	  }
	  config.contentMiddlewares = config.contentMiddlewares || []
	  config.contentMiddlewares.push(contentMiddleware)
	  return this
	}

	function register (name) {
	  if (typeof name !== 'string') {
	    throw new TypeError('first argument must be a string')
	  }
	  const config = this[secret.config]
	  const parentProto = config.element ? config.elementProto : HTMLElement.prototype
	  const proto = Object.create(parentProto)
	  config.shouldValidate = validateMiddlewares(config.contentMiddlewares, config.middlewares)
	  proto[secret.config] = config
	  proto.attachedCallback = attachedCallback
	  if (config.root) {
	    proto.detachedCallback = detachedCallback
	  }
	  return document.registerElement(name, {prototype: proto, extends: config.element})
	}

	function attachedCallback () {
	  const config = this[secret.config]
	  if (!this.$registered) {
	    if (typeof config.state === 'object') {
	      this.$state = config.state
	    } else if (config.state === true) {
	      this.$state = {}
	    } else if (config.state === 'inherit') {
	      this.$state = {}
	      this.$inheritState = true
	    }

	    this.$isolate = config.isolate
	    this.$contentMiddlewares = config.contentMiddlewares
	    this.$middlewares = config.middlewares
	    this.$shouldValidate = config.shouldValidate
	    this.$registered = true

	    if (config.root) {
	      this.$root = true
	      this[secret.contentWatcher] = new MutationObserver(onMutations)
	      this[secret.contentWatcher].observe(this, contentWatcherConfig)
	      onNodeAdded(this, getContext(this.parentNode))
	    } else {
	      if (addedNodes.size === 0) {
	        Promise.resolve().then(processAddedNodes)
	      }
	      addedNodes.add(this)
	    }
	  }
	}

	function detachedCallback () {
	  const contentWatcher = this[secret.contentWatcher]
	  if (contentWatcher) {
	    contentWatcher.disconnect()
	  }
	  onNodeRemoved(this)
	}

	function onMutations (mutations, contentWatcher) {
	  let mutationIndex = mutations.length
	  while (mutationIndex--) {
	    const mutation = mutations[mutationIndex]

	    let nodes = mutation.removedNodes
	    let nodeIndex = nodes.length
	    while (nodeIndex--) {
	      onNodeRemoved(nodes[nodeIndex])
	    }

	    nodes = mutation.addedNodes
	    nodeIndex = nodes.length
	    while (nodeIndex--) {
	      addedNodes.add(nodes[nodeIndex])
	    }
	  }
	  processAddedNodes()
	}

	function processAddedNodes () {
	  addedNodes.forEach(processAddedNode, addedNodeContext)
	  addedNodes.clear()
	}

	function processAddedNode (node) {
	  const parentNode = node.parentNode
	  if (this.parent !== parentNode) {
	    this.parent = parentNode
	    this.context = getContext(parentNode)
	  }
	  onNodeAdded(node, this.context)
	}


/***/ },
/* 6 */
/***/ function(module, exports) {

	'use strict'

	module.exports = function validateConfig (rawConfig) {
	  if (rawConfig === undefined) {
	    rawConfig = {}
	  }
	  if (typeof rawConfig !== 'object') {
	    throw new TypeError('invalid component config, must be an object or undefined')
	  }

	  const resultConfig = {}

	  if (typeof rawConfig.state === 'boolean' || rawConfig.state === 'inherit') {
	    resultConfig.state = rawConfig.state
	  } else if (typeof rawConfig.state === 'object' && observer.isObservable(rawConfig.state)) {
	    resultConfig.state = rawConfig.state
	  } else if (rawConfig.state === undefined) {
	    resultConfig.state = true
	  } else {
	    throw new Error('invalid state config: ' + rawConfig.state)
	  }

	  if (typeof rawConfig.isolate === 'boolean' || rawConfig.isolate === 'middlewares') {
	    resultConfig.isolate = rawConfig.isolate
	  } else if (rawConfig.isolate === undefined) {
	    resultConfig.isolate = false
	  } else {
	    throw new Error(`invalid isolate config: ${rawConfig.isolate}, must be a boolean, undefined or 'middlewares'`)
	  }

	  if (typeof rawConfig.root === 'boolean') {
	    resultConfig.root = rawConfig.root
	  } else if (rawConfig.root === undefined) {
	    resultConfig.root = false
	  } else {
	    throw new Error('invalid root config: ' + rawConfig.root)
	  }

	  if (resultConfig.root && (resultConfig.isolate || !resultConfig.state)) {
	    throw new Error('root components must have a state and must not be isolated')
	  }

	  if (typeof rawConfig.element === 'string') {
	    try {
	      resultConfig.elementProto = Object.getPrototypeOf(document.createElement(rawConfig.element))
	      resultConfig.element = rawConfig.element
	    } catch (err) {
	      throw new Error(`invalid element config: ${rawConfig.element}, must be the name of a native element`)
	    }
	  } else if (rawConfig.element !== undefined) {
	    throw new Error(`invalid element config: ${rawConfig.element}, must be the name of a native element`)
	  }
	  return resultConfig
	}


/***/ },
/* 7 */
/***/ function(module, exports) {

	'use strict'

	const names = new Set()
	const missing = new Set()
	const duplicates = new Set()

	module.exports = function validateMiddlewares (contentMiddlewares, middlewares, strict) {
	  names.clear()
	  missing.clear()
	  duplicates.clear()

	  if (contentMiddlewares) {
	    contentMiddlewares.forEach(validateMiddleware)
	  }
	  if (middlewares) {
	    middlewares.forEach(validateMiddleware)
	  }
	  if (missing.size) {
	    if (!strict) return true
	    throw new Error(`missing middlewares: ${Array.from(missing).join()}`)
	  }
	  if (duplicates.size) {
	    if (!strict) return true
	    throw new Error(`duplicate middlewares: ${Array.from(duplicates).join()}`)
	  }
	}

	function validateMiddleware (middleware) {
	  const name = middleware.$name
	  const require = middleware.$require
	  if (name) {
	    if (names.has(name)) {
	      duplicates.add(name)
	    }
	    names.add(name)
	  }
	  if (require) {
	    for (let dependency of require) {
	      if (!names.has(dependency)) {
	        missing.add(dependency)
	      }
	    }
	  }
	}


/***/ },
/* 8 */
/***/ function(module, exports) {

	'use strict'

	module.exports = function getContext (node) {
	  const context = {contentMiddlewares: []}

	  while (node) {
	    if (!context.state && node.$state) {
	      context.state = node.$state
	    }
	    if (!context.state && node.$contextState) {
	      context.state = node.$contextState
	    }
	    if (!context.isolate) {
	      context.isolate = node.$isolate
	      if (node.$contentMiddlewares) {
	        context.contentMiddlewares = node.$contentMiddlewares.concat(context.contentMiddlewares)
	      }
	    }
	    if (node.$root) {
	      return context
	    }
	    node = node.parentNode
	  }
	  return context
	}


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	const validateMiddlewares = __webpack_require__(7)
	const runMiddlewares = __webpack_require__(10)

	module.exports = function onNodeAdded (node, context) {
	  const parent = node.parentNode
	  const validParent = (parent && parent.$lifecycleStage === 'attached')
	  if (validParent && node.$root) {
	    throw new Error(`Nested root component: ${node.tagName}`)
	  }
	  if ((validParent || node.$root) && context.isolate !== true) {
	    setupNodeAndChildren(node, context.state, context.contentMiddlewares)
	  }
	}

	function setupNodeAndChildren (node, state, contentMiddlewares) {
	  const type = node.nodeType
	  if (!shouldProcess(node, type)) return
	  node.$lifecycleStage = 'attached'

	  node.$contextState = node.$contextState || state || node.$state
	  node.$state = node.$state || node.$contextState
	  if (node.$inheritState) {
	    Object.setPrototypeOf(node.$state, node.$contextState)
	  }

	  if (node.$isolate === 'middlewares') {
	    contentMiddlewares = node.$contentMiddlewares || []
	  } else if (node.$contentMiddlewares) {
	    contentMiddlewares = contentMiddlewares.concat(node.$contentMiddlewares)
	  }
	  if (node.$shouldValidate) {
	    validateMiddlewares(contentMiddlewares, node.$middlewares, true)
	  }
	  node.$cleanup = $cleanup

	  runMiddlewares(node, contentMiddlewares, node.$middlewares)

	  if (type === 1 && node.$isolate !== true) {
	    let child = node.firstChild
	    while (child) {
	      setupNodeAndChildren(child, node.$state, contentMiddlewares)
	      child = child.nextSibling
	    }
	  }
	}

	function shouldProcess (node, type) {
	  if (node.$lifecycleStage) {
	    return false
	  }
	  if (type === 1) {
	    return ((!node.hasAttribute('is') && node.tagName.indexOf('-') === -1) || node.$registered)
	  }
	  if (type === 3) {
	    return node.nodeValue.trim()
	  }
	}

	function $cleanup (fn, ...args) {
	  if (typeof fn !== 'function') {
	    throw new TypeError('first argument must be a function')
	  }
	  this.$cleaners = this.$cleaners || []
	  this.$cleaners.push({fn, args})
	}


/***/ },
/* 10 */
/***/ function(module, exports) {

	'use strict'

	let node
	let index, middlewares, middlewaresLength
	let contentIndex, contentMiddlewares, contentMiddlewaresLength

	module.exports = function runMiddlewares (currNode, currContentMiddlewares, currMiddlewares) {
	  node = currNode
	  middlewares = currMiddlewares
	  contentMiddlewares = currContentMiddlewares
	  middlewaresLength = currMiddlewares ? currMiddlewares.length : 0
	  contentMiddlewaresLength = currContentMiddlewares ? currContentMiddlewares.length : 0
	  index = contentIndex = 0
	  next()
	  node = middlewares = contentMiddlewares = undefined
	}

	function next () {
	  if (contentIndex < contentMiddlewaresLength) {
	    contentMiddlewares[contentIndex++].call(node, node, node.$state, next)
	    next()
	  } else if (index < middlewaresLength) {
	    middlewares[index++].call(node, node, node.$state, next)
	    next()
	  }
	}


/***/ },
/* 11 */
/***/ function(module, exports) {

	'use strict'

	module.exports = function onNodeRemoved (node) {
	  const parent = node.parentNode
	  if (!parent || parent.$lifecycleStage === 'detached') {
	    cleanupNodeAndChildren(node)
	  }
	}

	function cleanupNodeAndChildren (node) {
	  if (node.$lifecycleStage !== 'attached') return
	  node.$lifecycleStage = 'detached'

	  if (node.$cleaners) {
	    node.$cleaners.forEach(runCleaner, node)
	    node.$cleaners = undefined
	  }

	  let child = node.firstChild
	  while (child) {
	    cleanupNodeAndChildren(child)
	    child = child.nextSibling
	  }
	}

	function runCleaner (cleaner) {
	  cleaner.fn.apply(this, cleaner.args)
	}


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	module.exports = {
	  attributes: __webpack_require__(13),
	  code: __webpack_require__(14),
	  expression: __webpack_require__(16),
	  events: __webpack_require__(17),
	  interpolate: __webpack_require__(18),
	  render: __webpack_require__(19),
	  content: __webpack_require__(20),
	  flow: __webpack_require__(21),
	  bindable: __webpack_require__(22),
	  bind: __webpack_require__(23),
	  style: __webpack_require__(24),
	  animate: __webpack_require__(25),
	  router: __webpack_require__(26),
	  params: __webpack_require__(27),
	  ref: __webpack_require__(28),
	  observe: __webpack_require__(29)
	}


/***/ },
/* 13 */
/***/ function(module, exports) {

	'use strict'

	const handlers = new Map()
	const attributeCache = new Map()

	function attributes (elem, state, next) {
	  if (elem.nodeType !== 1) return

	  handlers.clear()
	  elem.$attribute = $attribute
	  next()
	  handleAttributes(elem, getAttributes(elem))
	}
	attributes.$name = 'attributes'
	attributes.$require = ['observe', 'expression']
	module.exports = attributes

	function $attribute (name, handler) {
	  if (typeof name !== 'string') {
	    throw new TypeError('first argument must be a string')
	  }
	  if (typeof handler !== 'function') {
	    throw new TypeError('second argument must be a function')
	  }
	  handlers.set(name, handler)
	}

	function getAttributes (elem) {
	  const cloneId = elem.getAttribute('clone-id')
	  if (cloneId) {
	    let attributes = attributeCache.get(cloneId)
	    if (!attributes) {
	      attributes = Array.prototype.map.call(elem.attributes, cacheAttribute)
	      attributeCache.set(cloneId, attributes)
	    }
	    return attributes
	  }
	  return elem.attributes
	}

	function cacheAttribute (attr) {
	  return {name: attr.name, value: attr.value}
	}

	function handleAttributes (elem, attributes) {
	  let i = attributes.length
	  while (i--) {
	    const attr = attributes[i]
	    const type = attr.name[0]

	    if (type === '@') {
	      attr.$name = attr.$name || attr.name.slice(1)
	      attr.$expression = attr.$expression || elem.$compileExpression(attr.value || attr.$name)
	      const handler = handlers.get(attr.$name) || defaultHandler
	      elem.$observe(expressionHandler, attr, handler)
	      continue
	    }

	    if (type === '$') {
	      attr.$name = attr.$name || attr.name.slice(1)
	      attr.$expression = attr.$expression || elem.$compileExpression(attr.value || attr.$name)
	      const handler = handlers.get(attr.$name) || defaultHandler
	      expressionHandler.call(elem, attr, handler)
	      continue
	    }

	    const handler = handlers.get(attr.name)
	    if (handler) {
	      handler.call(elem, attr.value, attr.name)
	    }
	  }
	}

	function defaultHandler (value, name) {
	  if (value) {
	    this.setAttribute(name, value)
	  } else {
	    this.removeAttribute(name)
	  }
	}

	function expressionHandler (attr, handler) {
	  const value = attr.$expression(this.$contextState)
	  handler.call(this, value, attr.$name)
	}


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	const compiler = __webpack_require__(15)

	const limiterRegex = /(?:[^\&]|\&\&)+/g
	const argsRegex = /\S+/g
	const codeCache = new Map()
	const limiters = new Map()

	function code (node) {
	  node.$compileCode = $compileCode
	}
	code.$name = 'code'
	code.limiter = limiter
	module.exports = code

	function $compileCode (rawCode) {
	  if (typeof rawCode !== 'string') {
	    throw new TypeError('first argument must be a string')
	  }
	  let code = codeCache.get(rawCode)
	  if (!code) {
	    code = parseCode(rawCode)
	    codeCache.set(rawCode, code)
	  }

	  if (typeof code === 'function') {
	    return code
	  }

	  const context = {}
	  return function evaluateCode (state, tempVars) {
	    let i = 0
	    function next () {
	      Object.assign(context, tempVars)
	      if (i < code.limiters.length) {
	        const limiter = code.limiters[i++]
	        const args = limiter.argExpressions.map(evaluateArgExpression, state)
	        limiter.effect(next, context, ...args)
	      } else {
	        code.exec(state, tempVars)
	      }
	    }
	    next()
	  }
	}

	function parseCode (rawCode) {
	  const tokens = rawCode.match(limiterRegex)
	  if (tokens.length === 1) {
	    return compiler.compileCode(tokens[0])
	  }

	  const code = {
	    exec: compiler.compileCode(tokens[0]),
	    limiters: []
	  }
	  for (let i = 1; i < tokens.length; i++) {
	    const limiterTokens = tokens[i].match(argsRegex) || []
	    const limiterName = limiterTokens.shift()
	    const effect = limiters.get(limiterName)
	    if (!effect) {
	      throw new Error(`there is no limiter named ${limiterName}`)
	    }
	    code.limiters.push({effect, argExpressions: limiterTokens.map(compileArgExpression)})
	  }
	  return code
	}

	function evaluateArgExpression (argExpression) {
	  return argExpression(this)
	}

	function compileArgExpression (argExpression) {
	  return compiler.compileExpression(argExpression)
	}

	function limiter (name, handler) {
	  if (typeof name !== 'string') {
	    throw new TypeError('first argument must be a string')
	  }
	  if (typeof handler !== 'function') {
	    throw new TypeError('second argument must be a function')
	  }
	  if (limiters.has(name)) {
	    throw new Error(`a limiter named ${name} is already registered`)
	  }
	  limiters.set(name, handler)
	  return this
	}


/***/ },
/* 15 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict'

	module.exports = {
	  compileCode,
	  compileExpression
	}

	let globalObj
	if (typeof window !== 'undefined') globalObj = window // eslint-disable-line
	else if (typeof global !== 'undefined') globalObj = global // eslint-disable-line
	else if (typeof self !== 'undefined') globalObj = self // eslint-disable-line
	globalObj.$nxCompileToSandbox = toSandbox
	globalObj.$nxCompileCreateBackup = createBackup

	const proxies = new WeakMap()
	const expressionCache = new Map()
	const codeCache = new Map()
	const handlers = {has}

	function compileExpression (src) {
	  if (typeof src !== 'string') {
	    throw new TypeError('first argument must be a string')
	  }
	  let expression = expressionCache.get(src)
	  if (!expression) {
	    expression = new Function('context', // eslint-disable-line
	      `const sandbox = $nxCompileToSandbox(context)
	      try { with (sandbox) { return ${src} } } catch (err) {
	        if (!(err instanceof TypeError)) throw err
	      }`)
	    expressionCache.set(src, expression)
	  }
	  return expression
	}

	function compileCode (src) {
	  if (typeof src !== 'string') {
	    throw new TypeError('first argument must be a string')
	  }
	  let code = codeCache.get(src)
	  if (!code) {
	    code = new Function('context, tempVars', // eslint-disable-line
	    `const backup = $nxCompileCreateBackup(context, tempVars)
	    Object.assign(context, tempVars)
	    const sandbox = $nxCompileToSandbox(context)
	    try {
	      with (sandbox) { ${src} }
	    } finally {
	      Object.assign(context, backup)
	    }`)
	    codeCache.set(src, code)
	  }
	  return code
	}

	function toSandbox (obj) {
	  if (typeof obj !== 'object') {
	    throw new TypeError('first argument must be an object')
	  }
	  let sandbox = proxies.get(obj)
	  if (!sandbox) {
	    sandbox = new Proxy(obj, handlers)
	    proxies.set(obj, sandbox)
	  }
	  return sandbox
	}

	function createBackup (context, tempVars) {
	  if (typeof tempVars === 'object') {
	    const backup = {}
	    for (let key of Object.keys(tempVars)) {
	      backup[key] = context[key]
	    }
	    return backup
	  }
	}

	function has () {
	  return true
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	const compiler = __webpack_require__(15)

	const filterRegex = /(?:[^\|]|\|\|)+/g
	const argsRegex = /\S+/g
	const expressionCache = new Map()
	const filters = new Map()

	function expression (node) {
	  node.$compileExpression = $compileExpression
	}
	expression.$name = 'expression'
	expression.filter = filter
	module.exports = expression

	function $compileExpression (rawExpression) {
	  if (typeof rawExpression !== 'string') {
	    throw new TypeError('first argument must be a string')
	  }
	  let expression = expressionCache.get(rawExpression)
	  if (!expression) {
	    expression = parseExpression(rawExpression)
	    expressionCache.set(rawExpression, expression)
	  }

	  if (typeof expression === 'function') {
	    return expression
	  }

	  return function evaluateExpression (contextState) {
	    let value = expression.exec(contextState)
	    for (let filter of expression.filters) {
	      const args = filter.argExpressions.map(evaluateArgExpression, contextState)
	      value = filter.effect(value, ...args)
	    }
	    return value
	  }
	}

	function parseExpression (rawExpression) {
	  const tokens = rawExpression.match(filterRegex)
	  if (tokens.length === 1) {
	    return compiler.compileExpression(tokens[0])
	  }

	  const expression = {
	    exec: compiler.compileExpression(tokens[0]),
	    filters: []
	  }
	  for (let i = 1; i < tokens.length; i++) {
	    let filterTokens = tokens[i].match(argsRegex) || []
	    const filterName = filterTokens.shift()
	    const effect = filters.get(filterName)
	    if (!effect) {
	      throw new Error(`there is no filter named ${filterName}`)
	    }
	    expression.filters.push({effect, argExpressions: filterTokens.map(compileArgExpression)})
	  }
	  return expression
	}

	function evaluateArgExpression (argExpression) {
	  return argExpression(this)
	}

	function compileArgExpression (argExpression) {
	  return compiler.compileExpression(argExpression)
	}

	function filter (name, handler) {
	  if (typeof name !== 'string') {
	    throw new TypeError('first argument must be a string')
	  }
	  if (typeof handler !== 'function') {
	    throw new TypeError('second argument must be a function')
	  }
	  if (filters.has(name)) {
	    throw new Error(`a filter named ${name} is already registered`)
	  }
	  filters.set(name, handler)
	  return this
	}


/***/ },
/* 17 */
/***/ function(module, exports) {

	'use strict'

	const secret = {
	  handlers: Symbol('event handlers')
	}
	const handlerCache = new Map()
	const handledEvents = new Set()

	function events (elem) {
	  if (elem.nodeType !== 1) return
	  elem[secret.handlers] = getEventHandlers(elem)
	}
	events.$name = 'events'
	events.$require = ['code']
	module.exports = events

	function getEventHandlers (elem) {
	  const cloneId = elem.getAttribute('clone-id')
	  if (cloneId) {
	    let handlers = handlerCache.get(cloneId)
	    if (handlers === undefined) {
	      handlers = createEventHandlers(elem)
	      handlerCache.set(cloneId, handlers)
	    }
	    return handlers
	  }
	  return createEventHandlers(elem)
	}

	function createEventHandlers (elem) {
	  let handlers = false
	  const attributes = elem.attributes
	  let i = attributes.length
	  while (i--) {
	    const attribute = attributes[i]
	    if (attribute.name[0] === '#') {
	      handlers = handlers || new Map()
	      const handler = elem.$compileCode(attribute.value)
	      const names = attribute.name.slice(1).split(',')
	      for (let name of names) {
	        let typeHandlers = handlers.get(name)
	        if (!typeHandlers) {
	          typeHandlers = new Set()
	          handlers.set(name, typeHandlers)
	        }
	        typeHandlers.add(handler)
	        if (!handledEvents.has(name)) {
	          document.addEventListener(name, listener, true)
	          handledEvents.add(name)
	        }
	      }
	    }
	  }
	  return handlers
	}

	function listener (event) {
	  const type = event.type
	  let elem = event.target
	  while (elem) {
	    runHandler(elem, event, type)
	    if (elem.$root) return
	    elem = elem.parentNode
	  }
	}

	function runHandler (elem, event, type) {
	  const handlers = elem[secret.handlers]
	  if (handlers) {
	    const typeHandlers = handlers.get(type)
	    if (typeHandlers) {
	      for (let handler of typeHandlers) {
	        handler(elem.$contextState, { $event: event })
	      }
	    }
	  }
	}


/***/ },
/* 18 */
/***/ function(module, exports) {

	'use strict'

	const tokenCache = new Map()

	function interpolate (node) {
	  if (node.nodeType !== 3) return
	  createTokens(node).forEach(processToken, node)
	}
	interpolate.$name = 'interpolate'
	interpolate.$require = ['observe', 'expression']
	module.exports = interpolate

	function createTokens (node) {
	  const nodeValue = node.nodeValue
	  let tokens = tokenCache.get(nodeValue)
	  if (!tokens) {
	    tokens = parseValue(node.nodeValue)
	    tokenCache.set(nodeValue, tokens)
	    return tokens
	  }
	  return tokens.map(cloneToken)
	}

	function cloneToken (token) {
	  if (typeof token === 'object') {
	    return {
	      observed: token.observed,
	      expression: token.expression,
	      toString: token.toString
	    }
	  }
	  return token
	}

	function processToken (token, index, tokens) {
	  if (typeof token === 'object') {
	    const expression = this.$compileExpression(token.expression)
	    if (token.observed) {
	      this.$observe(interpolateToken, expression, token, tokens)
	    } else {
	      interpolateToken.call(this, expression, token, tokens)
	    }
	  }
	}

	function interpolateToken (expression, token, tokens) {
	  let value = expression(this.$state)
	  value = (value !== undefined) ? value : ''
	  if (token.value !== value) {
	    token.value = value
	    this.nodeValue = (1 < tokens.length) ? tokens.join('') : value
	  }
	}

	function parseValue (string) {
	  const tokens = []
	  const length = string.length
	  let expression = false
	  let anchor = 0
	  let depth = 0
	  let token

	  for (let i = 0; i < length; i++) {
	    const char = string[i]

	    if (expression) {
	      if (char === '{') {
	        depth++
	      } else if (char === '}') {
	        depth--
	      }

	      if (depth === 0) {
	        token.expression = string.slice(anchor, i)
	        token.toString = tokenToString
	        tokens.push(token)
	        anchor = i + 1
	        expression = false
	      }
	    } else {
	      if (i === length - 1) {
	        tokens.push(string.slice(anchor, i + 1))
	      } else if ((char === '$' || char === '@') && string.charAt(i + 1) === '{') {
	        if (i !== anchor) {
	          tokens.push(string.slice(anchor, i))
	        }
	        token = {observed: (char === '@')}
	        anchor = i + 2
	        depth = 0
	        expression = true
	      }
	    }
	  }
	  return tokens
	}

	function tokenToString () {
	  return String(this.value)
	}


/***/ },
/* 19 */
/***/ function(module, exports) {

	'use strict'

	module.exports = function renderFactory (config) {
	  config = validateAndCloneConfig(config)
	  if (config.cache) {
	    config.template = cacheTemplate(config.template)
	  }
	  if (config.style) {
	    const style = document.createTextNode(config.style)
	    const styleContainer = document.createElement('style')
	    styleContainer.appendChild(style)
	    document.head.appendChild(styleContainer)
	  }

	  function render (elem) {
	    if (elem.nodeType !== 1) {
	      throw new Error('render only works with element nodes')
	    }

	    let template
	    if (config.cache) {
	      template = document.importNode(config.template, true)
	    } else {
	      template = cacheTemplate(config.template)
	    }
	    composeContentWithTemplate(elem, template)
	    elem.appendChild(template)
	  }
	  render.$name = 'render'
	  return render
	}

	function composeContentWithTemplate (elem, template) {
	  let defaultSlot

	  Array.prototype.forEach.call(template.querySelectorAll('slot'), (slot) => {
	    if (slot.getAttribute('name')) {
	      const slotFillers = elem.querySelectorAll(`[slot=${slot.getAttribute('name')}]`)
	      if (slotFillers.length) {
	        clearContent(slot)
	        for (let i = 0; i < slotFillers.length; i++) {
	          const slotFiller = slotFillers[i]
	          slotFiller.$contextState = elem.$contextState
	          slot.appendChild(slotFiller)
	        }
	      }
	    } else if (slot.hasAttribute('name')) {
	      defaultSlot = slot
	    }
	  })

	  if (defaultSlot && elem.childNodes.length) {
	    clearContent(defaultSlot)
	    while (elem.firstChild) {
	      elem.firstChild[exposed.contextState] = elem[exposed.contextState]
	      defaultSlot.appendChild(elem.firstChild)
	    }
	  }
	  clearContent(elem)
	}

	function cacheTemplate (template) {
	  const cachedTemplate = document.createElement('template')
	  cachedTemplate.innerHTML = template
	  return cachedTemplate.content
	}

	function clearContent (elem) {
	  while (elem.firstChild) {
	    elem.firstChild.remove()
	  }
	}

	function validateAndCloneConfig (rawConfig) {
	  const resultConfig = {}

	  if (typeof rawConfig !== 'object') {
	    throw new TypeError('config must be an object')
	  }

	  if (typeof rawConfig.template === 'string') {
	    resultConfig.template = rawConfig.template
	  } else {
	    throw new TypeError('template config must be a string')
	  }

	  if (typeof rawConfig.style === 'string') {
	    resultConfig.style = rawConfig.style
	  } else if (rawConfig.style !== undefined) {
	    throw new TypeError('template config must be a string or undefined')
	  }

	  if (typeof rawConfig.cache === 'boolean') {
	    resultConfig.cache = rawConfig.cache
	  } else if (rawConfig.cache === undefined) {
	    resultConfig.cache = true
	  } else {
	    throw new TypeError('cache config must be a boolean or undefined')
	  }

	  return resultConfig
	}


/***/ },
/* 20 */
/***/ function(module, exports) {

	'use strict'

	const secret = {
	  template: Symbol('content template'),
	  firstNodes: Symbol('first nodes')
	}
	let cloneId = 0

	function content (elem) {
	  if (elem.nodeType !== 1) return

	  elem.$extractContent = $extractContent
	  elem.$insertContent = $insertContent
	  elem.$moveContent = $moveContent
	  elem.$removeContent = $removeContent
	  elem.$clearContent = $clearContent
	  elem.$mutateContext = $mutateContext
	}
	content.$name = 'content'
	module.exports = content

	function $extractContent () {
	  const template = document.createDocumentFragment()
	  let node = this.firstChild
	  while (node) {
	    template.appendChild(node)
	    processContent(node)
	    node = this.firstChild
	  }
	  this[secret.template] = template
	  this[secret.firstNodes] = []
	  return template
	}

	function processContent (node) {
	  if (node.nodeType === 1) {
	    node.setAttribute('clone-id', cloneId++)
	    const childNodes = node.childNodes
	    let i = childNodes.length
	    while (i--) {
	      processContent(childNodes[i])
	    }
	  } else if (node.nodeType === 3) {
	    if (!node.nodeValue.trim()) node.remove()
	  } else {
	    node.remove()
	  }
	}

	function $insertContent (index, contextState) {
	  if (index !== undefined && typeof index !== 'number') {
	    throw new TypeError('first argument must be a number or undefined')
	  }
	  if (contextState !== undefined && typeof contextState !== 'object') {
	    throw new TypeError('second argument must be an object or undefined')
	  }
	  if (!this[secret.template]) {
	    throw new Error('you must extract a template with $extractContent before inserting')
	  }
	  const content = this[secret.template].cloneNode(true)
	  const firstNodes = this[secret.firstNodes]
	  const firstNode = content.firstChild
	  const beforeNode = firstNodes[index]

	  if (contextState) {
	    contextState = Object.assign(Object.create(this.$state), contextState)
	    let node = firstNode
	    while (node) {
	      node.$contextState = contextState
	      node = node.nextSibling
	    }
	  }

	  this.insertBefore(content, beforeNode)
	  if (beforeNode) firstNodes.splice(index, 0, firstNode)
	  else firstNodes.push(firstNode)
	}

	function $removeContent (index) {
	  if (index !== undefined && typeof index !== 'number') {
	    throw new TypeError('first argument must be a number or undefined')
	  }
	  const firstNodes = this[secret.firstNodes]
	  index = firstNodes[index] ? index : (firstNodes.length - 1)
	  const firstNode = firstNodes[index]
	  const nextNode = firstNodes[index + 1]


	  let node = firstNode
	  let next
	  while (node && node !== nextNode) {
	    next = node.nextSibling
	    node.remove()
	    node = next
	  }

	  if (nextNode) firstNodes.splice(index, 1)
	  else firstNodes.pop()
	}

	function $clearContent () {
	  this.innerHTML = ''
	  this[secret.firstNodes] = []
	}

	function $moveContent (fromIndex, toIndex, extraContext) {
	  if (typeof fromIndex !== 'number' || typeof toIndex !== 'number') {
	    throw new Error('first and second argument must be numbers')
	  }
	  if (extraContext !== undefined && typeof extraContext !== 'object') {
	    throw new Error('third argument must be an object or undefined')
	  }
	  const firstNodes = this[secret.firstNodes]
	  const fromNode = firstNodes[fromIndex]
	  const untilNode = firstNodes[fromIndex + 1]
	  const toNode = firstNodes[toIndex]

	  let node = fromNode
	  let next
	  while (node && node !== untilNode) {
	    next = node.nextSibling
	    this.insertBefore(node, toNode)
	    node = next
	  }
	  firstNodes.splice(fromIndex, 1)
	  firstNodes.splice(toIndex, 0, fromNode)

	  if (extraContext && fromNode && fromNode.$contextState) {
	    Object.assign(fromNode.$contextState, extraContext)
	  }
	}

	function $mutateContext (index, extraContext) {
	  if (index !== undefined && typeof index !== 'number') {
	    throw new TypeError('first argument must be a number or undefined')
	  }
	  if (typeof extraContext !== 'object') {
	    throw new TypeError('second argument must be an object')
	  }
	  const startNode = this[secret.firstNodes][index]
	  if (startNode && startNode.$contextState) {
	    Object.assign(startNode.$contextState, extraContext)
	  }
	}


/***/ },
/* 21 */
/***/ function(module, exports) {

	'use strict'

	const secret = {
	  showing: Symbol('flow showing'),
	  prevArray: Symbol('flow prevArray'),
	  hasIf: Symbol('has if'),
	  hasRepeat: Symbol('has repeat')
	}

	function flow (elem) {
	  if (elem.nodeType !== 1) return

	  elem.$attribute('if', ifAttribute)
	  elem.$attribute('repeat', repeatAttribute)
	}
	flow.$name = 'flow'
	flow.$require = ['content', 'attributes']
	module.exports = flow

	function ifAttribute (show) {
	  if (this[secret.hasRepeat]) {
	    throw new Error('You cant use if and repeat on the same node')
	  }
	  if (!this[secret.hasIf]) {
	    this.$extractContent()
	    this[secret.hasIf] = true
	  }

	  if (show && !this[secret.showing]) {
	    this.$insertContent()
	    this[secret.showing] = true
	  } else if (!show && this[secret.showing]) {
	    this.$clearContent()
	    this[secret.showing] = false
	  }
	}

	function repeatAttribute (array) {
	  if (this[secret.hasIf]) {
	    throw new Error('You cant use if and repeat on the same node')
	  }
	  if (!this[secret.hasRepeat]) {
	    this.$extractContent()
	    this[secret.hasRepeat] = true
	  }
	  const trackBy = this.getAttribute('track-by')
	  const repeatValue = this.getAttribute('repeat-value') || '$value'
	  const repeatIndex = this.getAttribute('repeat-index') || '$index'

	  array = array || []
	  const prevArray = this[secret.prevArray] = this[secret.prevArray] || []

	  let i = -1
	  iteration: for (let item of array) {
	    let prevItem = prevArray[++i]

	    if (prevItem === undefined) {
	      this.$insertContent(i, {[repeatIndex]: i, [repeatValue]: item})
	      prevArray[i] = item
	      continue
	    }
	    if (item === prevItem) {
	      this.$mutateContext(i, {[repeatIndex]: i})
	      continue
	    }
	    if (trackBy === repeatIndex) {
	      this.$mutateContext(i, {[repeatValue]: item})
	      prevArray[i] = item
	      continue
	    }
	    if (trackBy && isTrackBySame(item, prevItem, trackBy)) {
	      this.$mutateContext(i, {[repeatIndex]: i})
	      continue
	    }
	    for (let j = i + 1; j < prevArray.length; j++) {
	      prevItem = prevArray[j]
	      if (item === prevItem || (trackBy && isTrackBySame(item, prevItem, trackBy))) {
	        this.$moveContent(j, i, {[repeatIndex]: i})
	        prevArray.splice(i, 0, prevItem)
	        prevArray.splice(j, 1)
	        continue iteration
	      }
	    }
	    this.$insertContent(i, {[repeatIndex]: i, [repeatValue]: item})
	    prevArray.splice(i, 0, item)
	  }

	  if ((++i) === 0) {
	    prevArray.length = 0
	    this.$clearContent()
	  } else {
	    while (i < prevArray.length) {
	      this.$removeContent()
	      prevArray.pop()
	    }
	  }
	}

	function isTrackBySame (item1, item2, trackBy) {
	  return (typeof item1 === 'object' && typeof item2 === 'object' &&
	  item1 && item2 && item1[trackBy] === item2[trackBy])
	}


/***/ },
/* 22 */
/***/ function(module, exports) {

	'use strict'

	const secret = {
	  params: Symbol('bindable params'),
	  binder: Symbol('bindable binder')
	}
	const paramsRegex = /\S+/g
	const defaultParams = {mode: 'two-way', on: 'change', type: 'string'}

	document.addEventListener('submit', onSubmit, true)

	function onInput (ev) {
	  const params = ev.target[secret.params]
	  if (ev.type === 'submit') {
	    syncStateWithForm(ev.target)
	  } else if (params && (params.on.indexOf(ev.type) !== -1)) {
	    syncStateWithElement(ev.target)
	  }
	}

	function onSubmit (ev) {
	  ev.preventDefault()
	}

	function bindable (elem, state, next) {
	  if (elem.nodeType !== 1) return

	  elem.$bindable = $bindable
	  next()

	  if (elem[secret.params]) {
	    elem[secret.binder] = syncElementWithState.bind(null, elem)
	    elem.$attribute('bind', bindAttribute)
	  }
	}
	bindable.$name = 'bindable'
	bindable.$require = ['observe', 'attributes']
	module.exports = bindable

	function $bindable (params) {
	  if (typeof params !== 'object') params = {}
	  this[secret.params] = Object.assign({}, defaultParams, params)
	}

	function bindAttribute (params) {
	  if (typeof params === 'string') {
	    const tokens = params.match(paramsRegex)
	    params = {}
	    if (tokens) {
	      if (tokens[0]) params.mode = tokens[0]
	      if (tokens[1]) params.on = tokens[1].split(',')
	      if (tokens[2]) params.type = tokens[2]
	    }
	  }
	  if (typeof params === 'object') {
	    Object.assign(this[secret.params], params)
	  }
	  if (!Array.isArray(this[secret.params].on)) {
	    this[secret.params].on = [this[secret.params].on]
	  }
	  bindElement(this)
	}

	function bindElement (elem) {
	  const params = elem[secret.params]
	  const binder = elem[secret.binder]
	  let signal
	  if (params.mode === 'two-way') {
	    signal = elem.$observe(binder)
	    Promise.resolve().then(binder)
	  } else if (params.mode === 'one-time') {
	    elem.$unobserve(signal)
	    Promise.resolve().then(binder)
	  } else if (params.mode === 'one-way') {
	    elem.$unobserve(signal)
	  } else {
	    throw new TypeError('bind mode must be two-way, one-time or one-way')
	  }
	  for (let eventName of params.on) {
	    document.addEventListener(eventName, onInput, true)
	  }
	}

	function syncElementWithState (elem) {
	  const state = elem.$state
	  const params = elem[secret.params]
	  const value = getValue(state, elem.name)
	  if (elem.type === 'radio' || elem.type === 'checkbox') {
	    elem.checked = (value === toType(elem.value, params.type))
	  } else if (elem.value !== toType(value)) {
	    elem.value = toType(value)
	  }
	}

	function syncStateWithElement (elem) {
	  const state = elem.$state
	  const params = elem[secret.params]
	  if (elem.type === 'radio' || elem.type === 'checkbox') {
	    const value = elem.checked ? toType(elem.value, params.type) : undefined
	    setValue(state, elem.name, value)
	  } else {
	    setValue(state, elem.name, toType(elem.value, params.type))
	  }
	}

	function syncStateWithForm (form) {
	  Array.prototype.forEach.call(form.elements, syncStateWithFormControl)
	}

	function syncStateWithFormControl (elem) {
	  const params = elem[secret.params]
	  if (params && (params.on.indexOf('submit') !== -1)) {
	    syncStateWithElement(elem)
	  }
	}

	function toType (value, type) {
	  if (value === '') return undefined
	  if (value === undefined) return ''

	  if (type === 'string') return String(value)
	  else if (type === 'number') return Number(value)
	  else if (type === 'boolean') return Boolean(value)
	  else if (type === 'date') return new Date(value)
	  else if (type !== undefined) {
	    throw new TypeError('bind type must be string, number, boolean or date')
	  }

	  return value
	}

	function getValue (state, name) {
	  const tokens = name.split('.')
	  let value = state

	  for (let token of tokens) {
	    value = value[token]
	  }
	  return value
	}

	function setValue (state, name, value) {
	  const tokens = name.split('.')
	  const propName = tokens.pop()
	  let parent = state

	  for (let token of tokens) {
	    parent = parent[token]
	  }
	  parent[propName] = value
	}


/***/ },
/* 23 */
/***/ function(module, exports) {

	'use strict'

	function bind (elem) {
	  if (!isInput(elem)) return

	  elem.$bindable({
	    mode: 'two-way',
	    on: getTrigger(elem),
	    type: getType(elem)
	  })
	}
	bind.$name = 'bind'
	bind.$require = ['bindable']
	module.exports = bind

	function isInput (elem) {
	  if (elem instanceof HTMLInputElement) return true
	  if (elem instanceof HTMLTextAreaElement) return true
	  if (elem instanceof HTMLSelectElement) return true
	  return false
	}

	function getType (elem) {
	  if (elem instanceof HTMLInputElement) {
	    if (elem.type === 'checkbox') {
	      return 'boolean'
	    }
	    if (elem.type === 'number' || elem.type === 'range' || elem.type === 'week') {
	      return 'number'
	    }
	    if (elem.type === 'date' || elem.type === 'datetime') {
	      return 'date'
	    }
	    if (elem.type === 'datetime-local' || elem.type === 'month') {
	      return 'date'
	    }
	  }
	  return 'string'
	}

	function getTrigger (elem) {
	  if (elem.form && elem.form instanceof HTMLFormElement) {
	    return 'submit'
	  }
	  return 'change'
	}


/***/ },
/* 24 */
/***/ function(module, exports) {

	'use strict'

	function style (elem) {
	  if (elem.nodeType !== 1) return

	  elem.$attribute('class', classAttribute)
	  elem.$attribute('style', styleAttribute)
	}
	style.$name = 'style'
	style.$require = ['attributes']
	module.exports = style

	function classAttribute (classes) {
	  if (typeof classes === 'object') {
	    for (var item in classes) {
	      if (classes[item]) {
	        this.classList.add(item)
	      } else if (this.className) {
	        this.classList.remove(item)
	      }
	    }
	  } else if (this.className !== classes) {
	    this.className = classes
	  }
	}

	function styleAttribute (styles) {
	  if (typeof styles === 'object') {
	    Object.assign(this.style, styles)
	  } else if (this.style.cssText !== styles) {
	    this.style.cssText = styles
	  }
	}


/***/ },
/* 25 */
/***/ function(module, exports) {

	'use strict'

	const secret = {
	  entering: Symbol('during entering animation'),
	  leaving: Symbol('during leaving animation'),
	  moveTransition: Symbol('watch move transition'),
	  position: Symbol('animated element position')
	}
	const watchedNodes = new Set()
	let checkQueued = false

	window.addEventListener('animationend', onAnimationEnd, true)

	function onAnimationEnd (ev) {
	  const elem = ev.target
	  if (elem[secret.leaving]) {
	    elem.remove()
	  }
	  if (elem[secret.entering]) {
	    elem[secret.entering] = false
	    elem.style.animation = ''
	  }
	}

	function animate (elem) {
	  if (elem.nodeType !== 1) return

	  elem.$attribute('enter-animation', enterAttribute)
	  elem.$attribute('leave-animation', leaveAttribute)
	  elem.$attribute('move-animation', moveAttribute)

	  queueCheck()
	  elem.$cleanup(queueCheck)
	}
	animate.$name = 'animate'
	animate.$require = ['attributes']
	module.exports = animate

	function enterAttribute (animation) {
	  if (this[secret.entering] !== false) {
	    this[secret.entering] = true
	    if (typeof animation === 'object' && animation !== null) {
	      this.style.animation = animationObjectToString (animation)
	    } else if (typeof animation === 'string') {
	      this.style.animation = animation
	    }
	    setAnimationDefaults(this)
	  }
	}

	function leaveAttribute (animation) {
	  const parent = this.parentNode
	  watchedNodes.add(this)
	  this.$cleanup(unwatch)
	  this.$cleanup(() => {
	    this[secret.leaving] = true
	    if (typeof animation === 'object' && animation !== null) {
	      this.style.animation = animationObjectToString (animation)
	    } else if (typeof animation === 'string') {
	      this.style.animation = animation
	    }
	    setAnimationDefaults(this)
	    parent.appendChild(this)
	    if (shouldAbsolutePosition(this)) {
	      toAbsolutePosition(this)
	    }
	  })
	}

	function moveAttribute (transition) {
	  this[secret.moveTransition] = true
	  watchedNodes.add(this)
	  this.$cleanup(unwatch)
	  if (typeof transition === 'object' && transition !== null) {
	    this.style.transition = transitionObjectToString(transition)
	  } else if (typeof transition === 'string') {
	    this.style.transition = 'transform ' + transition
	  } else {
	    this.style.transition = 'transform'
	  }
	  setTransitionDefaults(this)
	}

	function unwatch () {
	  watchedNodes.delete(this)
	}

	function queueCheck () {
	  if (!checkQueued) {
	    checkQueued = true
	    requestAnimationFrame(checkWatchedNodes)
	  }
	}

	function checkWatchedNodes () {
	  for (let elem of watchedNodes) {
	    const rect = elem.getBoundingClientRect() || {}
	    const position = {
	      left: elem.offsetLeft,
	      top: elem.offsetTop
	    }
	    const prevPosition = elem[secret.position] || {}
	    elem[secret.position] = position

	    const xDiff = (prevPosition.left - position.left) || 0
	    const yDiff = (prevPosition.top - position.top) || 0
	    if (elem[secret.moveTransition] && (xDiff || yDiff)) {
	      onMove(elem, xDiff, yDiff)
	    }
	  }
	  checkQueued = false
	}

	function onMove (elem, xDiff, yDiff) {
	  const transition = elem.style.transition
	  elem.style.transition = ''
	  elem.style.transform = `translate3d(${xDiff}px, ${yDiff}px, 0)`
	  requestAnimationFrame(() => {
	    elem.style.transition = transition
	    elem.style.transform = ''
	  })
	}

	function animationObjectToString (animation) {
	  return [
	    animation.name,
	    timeToString(animation.duration) || '1s',
	    animation.timingFunction,
	    timeToString(animation.delay),
	    animation.iterationCount,
	    animation.direction,
	    animation.fillMode,
	    boolToPlayState(animation.playState)
	  ].join(' ')
	}

	function transitionObjectToString (transition) {
	  return [
	    timeToString(transition.duration),
	    timeToString(transition.delay),
	    transition.timingFunction
	  ].join(' ')
	}

	function setAnimationDefaults (elem) {
	  const style = elem.style
	  if (style.animationDuration === 'initial' || style.animationDuration === '') {
	    elem.style.animationDuration = '1s'
	  }
	  if (style.animationFillMode === 'initial' || style.animationFillMode === '' || style.animationFillMode === 'none') {
	    style.animationFillMode = 'both'
	  }
	}

	function setTransitionDefaults (elem) {
	  const style = elem.style
	  if (style.transitionDuration === 'initial' || style.transitionDuration === '') {
	    style.transitionDuration = '1s'
	  }
	}

	function shouldAbsolutePosition (elem) {
	  while (elem) {
	    elem = elem.parentNode
	    if (elem[secret.leaving]) {
	      return false
	    }
	    if (elem.$root) {
	      return true
	    }
	  }
	  return true
	}

	function toAbsolutePosition (elem) {
	  const style = elem.style
	  const position = elem[secret.position]
	  style.left = `${position.left}px`
	  style.top = `${position.top}px`
	  style.width = `${elem.offsetWidth + 1}px` // it always rounds downwards
	  style.height = `${elem.offsetHeight + 1}px` // it always rounds downwards
	  style.margin = '0'
	  style.boxSizing = 'border-box'
	  style.position = 'absolute'
	}

	function timeToString (time) {
	  if (typeof time === 'number') {
	    return time + 'ms'
	  }
	  return time
	}

	function boolToPlayState (bool) {
	  if (bool === false || bool === 'paused') {
	    return 'paused'
	  }
	}


/***/ },
/* 26 */
/***/ function(module, exports) {

	'use strict'

	const secret = {
	  config: Symbol('router config')
	}
	const rootRouters = new Set()

	window.addEventListener('popstate', onPopState, true)

	function onPopState (ev) {
	  for (let router of rootRouters) {
	    routeRouterAndChildren(router, history.state.route)
	  }
	}

	function router (router) {
	  if (router.nodeType !== 1) {
	    throw new Error('router only works with element nodes')
	  }
	  setupRouter(router)
	  extractViews(router)
	  routeRouterAndChildren(router, absoluteToRelativeRoute(router, history.state.route))
	}
	router.$name = 'router'
	module.exports = router

	function setupRouter (router) {
	  router[secret.config] = {
	    children: new Set(),
	    templates: new Map()
	  }
	  const parentRouter = findParentRouter(router)
	  if (parentRouter) {
	    router.$routerLevel = parentRouter.$routerLevel + 1
	    parentRouter[secret.config].children.add(router)
	    router.$cleanup(() => parentRouter[secret.config].children.delete(router))
	  } else {
	    router.$routerLevel = 1
	    rootRouters.add(router)
	    router.$cleanup(() => rootRouters.delete(router))
	  }
	}

	function absoluteToRelativeRoute (router, route) {
	  return route.slice(router.$routerLevel - 1)
	}

	function extractViews (router) {
	  let view
	  while (router.firstChild) {
	    view = router.firstChild
	    if (view instanceof Element && view.hasAttribute('route')) {
	      router[secret.config].templates.set(view.getAttribute('route'), view)
	      if (view.hasAttribute('default-route')) {
	        router[secret.config].defaultView = view.getAttribute('route')
	      }
	    }
	    view.remove()
	  }
	}

	function findParentRouter (node) {
	  while (node.parentNode) {
	    node = node.parentNode
	    if (node.$routerLevel !== undefined) {
	      return node
	    }
	  }
	}

	function routeRouterAndChildren (router, route) {
	  route = route.slice()
	  const templates = router[secret.config].templates
	  const defaultView = router[secret.config].defaultView
	  const prevView = router.$currentView
	  let nextView = route.shift()

	  if (!templates.has(nextView) && templates.has(defaultView)) {
	    nextView = defaultView
	  }
	  if (prevView !== nextView) {
	    const eventConfig = {
	      bubbles: true,
	      cancelable: true,
	      detail: {
	        from: prevView,
	        to: nextView
	      }
	    }
	    const routeEvent = new CustomEvent('route', eventConfig)
	    router.dispatchEvent(routeEvent)

	    if (!routeEvent.defaultPrevented) {
	      routeRouter(router, nextView)
	      router.$currentView = nextView
	    }
	  } else {
	    routeChildren(router, route)
	  }
	}

	function routeRouter (router, nextView) {
	  const template = router[secret.config].templates.get(nextView)

	  while (router.firstChild) {
	    router.firstChild.remove()
	  }
	  if (template) {
	    router.appendChild(document.importNode(template, true))
	  }
	}

	function routeChildren (router, route) {
	  for (let childRouter of router[secret.config].children) {
	    routeRouterAndChildren(childRouter, route)
	  }
	}


/***/ },
/* 27 */
/***/ function(module, exports) {

	'use strict'

	const secret = {
	  config: Symbol('params sync config')
	}
	const nodesToSync = new Set()

	window.addEventListener('popstate', onPopState)

	function onPopState (ev) {
	  for (let node of nodesToSync) {
	    if (document.body.contains(node)) { // TODO -> refine this a bit! I need a better check
	      const state = node.$state
	      const config = node[secret.config]
	      syncStateWithParams(state, history.state.params, config)
	      syncParamsWithState(history.state.params, state, config, false)
	    }
	  }
	}

	module.exports = function paramsFactory (config) {
	  function params (node, state, next) {
	    node[secret.config] = config
	    nodesToSync.add(node)
	    node.$cleanup(() => nodesToSync.delete(node))

	    syncStateWithParams(state, history.state.params, config)

	    next()

	    syncParamsWithState(history.state.params, state, config, false)
	    node.$observe(() => syncParamsWithState(history.state.params, state, config, true))
	  }
	  params.$name = 'params'
	  params.$require = ['observe']
	  return params
	}

	function syncStateWithParams (state, params, config) {
	  for (let paramName in config) {
	    const param = params[paramName] || config[paramName].default
	    const type = config[paramName].type

	    if (config[paramName].required && param === undefined) {
	      throw new Error(`${paramName} is a required parameter`)
	    }
	    if (state[paramName] !== param) {
	      if (param === undefined) {
	        state[paramName] = undefined
	      } else if (type === 'number') {
	        state[paramName] = Number(param)
	      } else if (type === 'string') {
	        state[paramName] = String(param)
	      } else if (type === 'boolean') {
	        state[paramName] = Boolean(param)
	      } else if (type === 'date') {
	        state[paramName] = new Date(param)
	      } else {
	        state[paramName] = param
	      }
	    }
	  }
	}

	function syncParamsWithState (params, state, config, shouldUpdateHistory) {
	  let newParams = {}
	  let paramsChanged = false
	  let historyChanged = false

	  for (let paramName in config) {
	    if (params[paramName] !== state[paramName]) {
	      if (config[paramName].readOnly) {
	        throw new Error(`${paramName} is readOnly`)
	      }
	      newParams[paramName] = state[paramName]
	      paramsChanged = true
	      if (config[paramName].history && shouldUpdateHistory) {
	        historyChanged = true
	      }
	    }
	  }
	  if (paramsChanged) {
	    updateHistory(newParams, historyChanged)
	  }
	}

	function updateHistory (params, historyChanged) {
	  params = Object.assign({}, history.state.params, params)

	  const url = location.pathname + paramsToQuery(params)
	  if (historyChanged) {
	    history.pushState({route: history.state.route, params}, '', url)
	  } else {
	    history.replaceState({route: history.state.route, params}, '', url)
	  }
	}

	function paramsToQuery (params) {
	  if (params === undefined) {
	    params = {}
	  }

	  let query = ''
	  for (let param in params) {
	    if (params[param] !== undefined) {
	      query += `${param}=${params[param]}&`
	    }
	  }
	  if (query !== '') {
	    query = '?' + query.slice(0, -1)
	  }
	  return query
	}


/***/ },
/* 28 */
/***/ function(module, exports) {

	'use strict'

	const secret = {
	  config: Symbol('ref config')
	}

	updateHistory(pathToRoute(location.pathname), queryToParams(location.search), {history: false})

	function ref (elem) {
	  if (elem.nodeType !== 1) return

	  elem.$route = $route
	  if (elem instanceof HTMLAnchorElement) {
	    elem.$attribute('iref', irefAttribute)
	    elem.$attribute('iref-params', irefParamsAttribute)
	    elem.$attribute('iref-options', irefOptionsAttribute)
	  }
	}
	ref.$name = 'ref'
	ref.$require = ['attributes']
	module.exports = ref

	function irefAttribute (path) {
	  this[secret.config] = this[secret.config] || {}
	  const config = this[secret.config]
	  config.path = path

	  const href = path + (this.search || '')
	  this.setAttribute('href', href)
	  this.addEventListener('click', onClick, true)
	}

	function irefParamsAttribute (params) {
	  this[secret.config] = this[secret.config] || {}
	  const config = this[secret.config]
	  config.params = params

	  const href = (this.pathname || '') + paramsToQuery(params)
	  this.setAttribute('href', href)
	  this.addEventListener('click', onClick, true)
	}

	function onClick (ev) {
	  const config = this[secret.config]
	  if (config) {
	    this.$route(config.path, config.params, config.options)
	    ev.preventDefault()
	  }
	}

	function irefOptionsAttribute (options) {
	  this[secret.config] = this[secret.config] || {}
	  this[secret.config].options = options
	}

	function $route (path, params, options) {
	  if (params === undefined) {
	    params = {}
	  }
	  if (options === undefined) {
	    options = {}
	  }
	  let route = pathToRoute(path)
	  if (route.some(filterRelativeTokens)) {
	    route = relativeToAbsoluteRoute(this, route)
	  }
	  updateHistory(route, params, options)
	  window.scroll(0, 0)
	}

	function relativeToAbsoluteRoute (node, relativeRoute) {
	  let router = findParentRouter(node)
	  let routerLevel = router ? router.$routerLevel : 0

	  for (let token of relativeRoute) {
	    if (token === '..') routerLevel--
	  }
	  if (routerLevel < 0) {
	    throw new Error('invalid relative route')
	  }

	  const currentRoute = []
	  while (router) {
	    currentRoute.unshift(router.$currentView)
	    router = findParentRouter(router)
	  }
	  const route = relativeRoute.filter(filterAbsoluteTokens)
	  return currentRoute.slice(0, routerLevel).concat(route)
	}

	function filterAbsoluteTokens (token) {
	  return (token !== '..' && token !== '.')
	}

	function filterRelativeTokens (token) {
	  return (token === '..' || token === '.')
	}

	function filterEmptyTokens (token) {
	  return (token !== '')
	}

	function findParentRouter (node) {
	  while(node.parentNode) {
	    node = node.parentNode
	    if (node.$routerLevel !== undefined) {
	      return node
	    }
	  }
	}

	function updateHistory (route, params, options) {
	  if (options.inherit) {
	    params = Object.assign({}, history.state.params, params)
	  }

	  const url = routeToPath(route) + paramsToQuery(params)
	  if (options.history === false) {
	    history.replaceState({route, params}, '', url)
	  } else {
	    history.pushState({route, params}, '', url)
	  }

	  const eventConfig = {bubbles: true, cancelable: false }
	  document.dispatchEvent(new Event('popstate', eventConfig))
	}

	function routeToPath (route) {
	  if (route === undefined) {
	    route = []
	  }
	  return '/' + route.join('/')
	}

	function pathToRoute (path) {
	  if (path.charAt(0) === '/') {
	    path = path.slice(1)
	  }
	  return path.split('/').filter(filterEmptyTokens)
	}

	function paramsToQuery (params) {
	  if (params === undefined) {
	    params = {}
	  }

	  let query = ''
	  for (let param in params) {
	    if (params[param] !== undefined) {
	      query += `${param}=${params[param]}&`
	    }
	  }
	  if (query !== '') {
	    query = '?' + query.slice(0, -1)
	  }
	  return query
	}

	function queryToParams (query) {
	  if (query.charAt(0) === '?') {
	    query = query.slice(1)
	  }
	  query = query.split('&')

	  const params = {}
	  for (let keyValue of query) {
	    keyValue = keyValue.split('=')
	    if (keyValue.length === 2) {
	      params[keyValue[0]] = keyValue[1]
	    }
	  }
	  return params
	}


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	const observer = __webpack_require__(30)

	function observe (node, state) {
	  node.$contextState = observer.observable(node.$contextState)
	  node.$state = observer.observable(node.$state)

	  node.$observe = $observe
	  node.$unobserve = observer.unobserve
	}
	observe.$name = 'observe'
	module.exports = observe

	function $observe (fn, ...args) {
	  if (typeof fn !== 'function') {
	    throw new TypeError('first argument must be a function')
	  }
	  args.unshift(fn, this)
	  const signal = observer.observe.apply(null, args)
	  this.$cleanup(observer.unobserve, signal)
	  return signal
	}


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	const nextTick = __webpack_require__(31)

	const proxies = new WeakMap()
	const observers = new WeakMap()
	const queuedObservers = new Set()
	let queued = false
	let currentObserver

	module.exports = {
	  observe,
	  unobserve,
	  observable,
	  isObservable
	}

	const handlers = {get, set, deleteProperty}

	function observe (fn, context, ...args) {
	  if (typeof fn !== 'function') {
	    throw new TypeError('first argument must be a function')
	  }
	  args = args.length ? args : undefined
	  const observer = {fn, context, args, observedKeys: []}
	  runObserver(observer)
	  return observer
	}

	function unobserve (observer) {
	  if (typeof observer === 'object' && observer.observedKeys) {
	    observer.observedKeys.forEach(unobserveKey, observer)
	    observer.fn = observer.context = observer.args = observer.observedKeys = undefined
	  }
	}

	function observable (obj) {
	  obj = obj || {}
	  if (typeof obj !== 'object') {
	    throw new TypeError('first argument must be an object or undefined')
	  }
	  return proxies.get(obj) || toObservable(obj)
	}

	function toObservable (obj) {
	  const observable = new Proxy(obj, handlers)
	  proxies.set(obj, observable)
	  proxies.set(observable, observable)
	  observers.set(obj, new Map())
	  return observable
	}

	function isObservable (obj) {
	  if (typeof obj !== 'object') {
	    throw new TypeError('first argument must be an object')
	  }
	  return (proxies.get(obj) === obj)
	}

	function get (target, key, receiver) {
	  if (key === '$raw') return target
	  const result = Reflect.get(target, key, receiver)
	  if (typeof key === 'symbol' || typeof result === 'function') {
	    return result
	  }
	  const isObject = (typeof result === 'object')
	  const observable = isObject && proxies.get(result)
	  if (currentObserver) {
	    registerObserver(target, key, currentObserver)
	    if (isObject && result.constructor !== Date) {
	      return observable || toObservable(result)
	    }
	  }
	  return observable || result
	}

	function registerObserver (target, key, observer) {
	  const observersForTarget = observers.get(target)
	  let observersForKey = observersForTarget.get(key)
	  if (!observersForKey) {
	    observersForKey = new Set()
	    observersForTarget.set(key, observersForKey)
	  }
	  if (!observersForKey.has(observer)) {
	    observersForKey.add(observer)
	    observer.observedKeys.push(observersForKey)
	  }
	}

	function set (target, key, value, receiver) {
	  const observersForKey = observers.get(target).get(key)
	  if (observersForKey) {
	    observersForKey.forEach(queueObserver)
	  }
	  return Reflect.set(target, key, value, receiver)
	}

	function deleteProperty (target, key) {
	  const observersForKey = observers.get(target).get(key)
	  if (observersForKey) {
	    observersForKey.forEach(queueObserver)
	  }
	  return Reflect.deleteProperty(target, key)
	}

	function queueObserver (observer) {
	  if (!queued) {
	    nextTick(runObservers)
	    queued = true
	  }
	  queuedObservers.add(observer)
	}

	function runObservers () {
	  queuedObservers.forEach(runObserver)
	  queuedObservers.clear()
	  queued = false
	}

	function runObserver (observer) {
	  if (observer.fn) {
	    try {
	      currentObserver = observer
	      observer.fn.apply(observer.context, observer.args)
	    } finally {
	      currentObserver = undefined
	    }
	  }
	}

	function unobserveKey (observersForKey) {
	  observersForKey.delete(this)
	}


/***/ },
/* 31 */
/***/ function(module, exports) {

	'use strict'

	let mutateWithTask
	let currTask

	if (typeof MutationObserver !== 'undefined') {
	  let counter = 0
	  const observer = new MutationObserver(onTask)
	  const textNode = document.createTextNode(String(counter))
	  observer.observe(textNode, {characterData: true})

	  function onTask () {
	    if (currTask) {
	      currTask()
	    }
	  }

	  mutateWithTask = function mutateWithTask () {
	    counter = (counter + 1) % 2
	    textNode.textContent = counter
	  }
	}

	module.exports = function nextTick (task) {
	  currTask = task
	  if (mutateWithTask) {
	    mutateWithTask()
	  } else {
	    Promise.resolve().then(task)
	  }
	}


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	module.exports = {
	  app: __webpack_require__(33),
	  router: __webpack_require__(34)
	}


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	const component = __webpack_require__(4)
	const middlewares = __webpack_require__(12)

	module.exports = function app (config) {
	  config = Object.assign({root: true}, config)

	  return component(config)
	    .useOnContent(middlewares.observe)
	    .useOnContent(middlewares.code)
	    .useOnContent(middlewares.expression)
	    .useOnContent(middlewares.interpolate)
	    .useOnContent(middlewares.attributes)
	    .useOnContent(middlewares.style)
	    .useOnContent(middlewares.animate)
	    .useOnContent(middlewares.ref)
	    .useOnContent(middlewares.content)
	    .useOnContent(middlewares.flow)
	    .useOnContent(middlewares.bindable)
	    .useOnContent(middlewares.bind)
	    .useOnContent(middlewares.events)
	}


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	const component = __webpack_require__(4)
	const middlewares = __webpack_require__(12)

	module.exports = function routerComp (config) {
	  return component(config)
	    .use(middlewares.router)
	}


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	module.exports = {
	  capitalize: __webpack_require__(36),
	  uppercase: __webpack_require__(37),
	  lowercase: __webpack_require__(38),
	  unit: __webpack_require__(39),
	  json: __webpack_require__(40),
	  slice: __webpack_require__(41),
	  date: __webpack_require__(42),
	  time: __webpack_require__(43),
	  datetime: __webpack_require__(44)
	}


/***/ },
/* 36 */
/***/ function(module, exports) {

	'use strict'

	module.exports = function capitalize (value) {
	  if (value === undefined) {
	    return value
	  }
	  value = String(value)
	  return value.charAt(0).toUpperCase() + value.slice(1)
	}


/***/ },
/* 37 */
/***/ function(module, exports) {

	'use strict'

	module.exports = function uppercase (value) {
	  if (value === undefined) {
	    return value
	  }
	  return String(value).toUpperCase()
	}


/***/ },
/* 38 */
/***/ function(module, exports) {

	'use strict'

	module.exports = function lowercase (value) {
	  if (value === undefined) {
	    return value
	  }
	  return String(value).toLowerCase()
	}


/***/ },
/* 39 */
/***/ function(module, exports) {

	'use strict'

	module.exports = function unit (value, unitName, postfix) {
	  unitName = unitName || 'item'
	  postfix = postfix || 's'
	  if (isNaN(value)) {
	    return value + ' ' + unitName
	  }
	  let result = value + ' ' + unitName
	  if (value !== 1) result += postfix
	  return result
	}


/***/ },
/* 40 */
/***/ function(module, exports) {

	'use strict'

	module.exports = function json (value, indent) {
	  if (value === undefined) {
	    return value
	  }
	  return JSON.stringify(value, null, indent)
	}


/***/ },
/* 41 */
/***/ function(module, exports) {

	'use strict'

	module.exports = function slice (value, begin, end) {
	  if (value === undefined) {
	    return value
	  }
	  return value.slice(begin, end)
	}


/***/ },
/* 42 */
/***/ function(module, exports) {

	'use strict'

	module.exports = function date (value) {
	  if (value instanceof Date) {
	    return value.toLocaleDateString()
	  }
	  return value
	}


/***/ },
/* 43 */
/***/ function(module, exports) {

	'use strict'

	module.exports = function time (value) {
	  if (value instanceof Date) {
	    return value.toLocaleTimeString()
	  }
	  return value
	}


/***/ },
/* 44 */
/***/ function(module, exports) {

	'use strict'

	module.exports = function datetime (value) {
	  if (value instanceof Date) {
	    return value.toLocaleString()
	  }
	  return value
	}


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	module.exports = {
	  if: __webpack_require__(46),
	  delay: __webpack_require__(47),
	  debounce: __webpack_require__(48),
	  throttle: __webpack_require__(49),
	  key: __webpack_require__(50)
	}


/***/ },
/* 46 */
/***/ function(module, exports) {

	'use strict'

	module.exports = function ifLimiter (next, context, condition) {
	  if (condition) {
	    next()
	  }
	}


/***/ },
/* 47 */
/***/ function(module, exports) {

	'use strict'

	module.exports = function delay (next, context, time) {
	  if (time === undefined || isNaN(time)) {
	    time = 200
	  }
	  setTimeout(next, time)
	}


/***/ },
/* 48 */
/***/ function(module, exports) {

	'use strict'

	const timer = Symbol('debounce timer')

	module.exports = function debounce (next, context, delay) {
	  if (delay === undefined || isNaN(delay)) {
	    delay = 200
	  }
	  clearTimeout(context[timer])
	  context[timer] = setTimeout(next, delay)
	}


/***/ },
/* 49 */
/***/ function(module, exports) {

	'use strict'

	const timer = Symbol('throttle timer')
	const lastExecution = Symbol('throttle last execution')

	module.exports = function throttle (next, context, threshold) {
	  if (threshold === undefined || isNaN(threshold)) {
	    threshold = 200
	  }
	  const last = context[lastExecution]
	  if (last && Date.now() < (last + threshold)) {
	    clearTimeout(context[timer])
	    context[timer] = setTimeout(execute, context, next, threshold)
	  } else {
	    execute(context, next)
	  }
	}

	function execute (context, next) {
	  context[lastExecution] = Date.now()
	  next()
	}


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	const stringToCode = __webpack_require__(51)

	module.exports = function keyLimiter (next, context, ...keys) {
	  if (!(context.$event instanceof KeyboardEvent)) {
	    return next()
	  }

	  const keyCodes = keys.map(stringToCode)
	  const keyCode = context.$event.keyCode || context.$event.which
	  if (keyCodes.indexOf(keyCode) !== -1) {
	    next()
	  }
	}


/***/ },
/* 51 */
/***/ function(module, exports) {

	// Source: http://jsfiddle.net/vWx8V/
	// http://stackoverflow.com/questions/5603195/full-list-of-javascript-keycodes

	/**
	 * Conenience method returns corresponding value for given keyName or keyCode.
	 *
	 * @param {Mixed} keyCode {Number} or keyName {String}
	 * @return {Mixed}
	 * @api public
	 */

	exports = module.exports = function(searchInput) {
	  // Keyboard Events
	  if (searchInput && 'object' === typeof searchInput) {
	    var hasKeyCode = searchInput.which || searchInput.keyCode || searchInput.charCode
	    if (hasKeyCode) searchInput = hasKeyCode
	  }

	  // Numbers
	  if ('number' === typeof searchInput) return names[searchInput]

	  // Everything else (cast to string)
	  var search = String(searchInput)

	  // check codes
	  var foundNamedKey = codes[search.toLowerCase()]
	  if (foundNamedKey) return foundNamedKey

	  // check aliases
	  var foundNamedKey = aliases[search.toLowerCase()]
	  if (foundNamedKey) return foundNamedKey

	  // weird character?
	  if (search.length === 1) return search.charCodeAt(0)

	  return undefined
	}

	/**
	 * Get by name
	 *
	 *   exports.code['enter'] // => 13
	 */

	var codes = exports.code = exports.codes = {
	  'backspace': 8,
	  'tab': 9,
	  'enter': 13,
	  'shift': 16,
	  'ctrl': 17,
	  'alt': 18,
	  'pause/break': 19,
	  'caps lock': 20,
	  'esc': 27,
	  'space': 32,
	  'page up': 33,
	  'page down': 34,
	  'end': 35,
	  'home': 36,
	  'left': 37,
	  'up': 38,
	  'right': 39,
	  'down': 40,
	  'insert': 45,
	  'delete': 46,
	  'command': 91,
	  'left command': 91,
	  'right command': 93,
	  'numpad *': 106,
	  'numpad +': 107,
	  'numpad -': 109,
	  'numpad .': 110,
	  'numpad /': 111,
	  'num lock': 144,
	  'scroll lock': 145,
	  'my computer': 182,
	  'my calculator': 183,
	  ';': 186,
	  '=': 187,
	  ',': 188,
	  '-': 189,
	  '.': 190,
	  '/': 191,
	  '`': 192,
	  '[': 219,
	  '\\': 220,
	  ']': 221,
	  "'": 222
	}

	// Helper aliases

	var aliases = exports.aliases = {
	  'windows': 91,
	  '': 16,
	  '': 18,
	  '': 17,
	  '': 91,
	  'ctl': 17,
	  'control': 17,
	  'option': 18,
	  'pause': 19,
	  'break': 19,
	  'caps': 20,
	  'return': 13,
	  'escape': 27,
	  'spc': 32,
	  'pgup': 33,
	  'pgdn': 34,
	  'ins': 45,
	  'del': 46,
	  'cmd': 91
	}


	/*!
	 * Programatically add the following
	 */

	// lower case chars
	for (i = 97; i < 123; i++) codes[String.fromCharCode(i)] = i - 32

	// numbers
	for (var i = 48; i < 58; i++) codes[i - 48] = i

	// function keys
	for (i = 1; i < 13; i++) codes['f'+i] = i + 111

	// numpad keys
	for (i = 0; i < 10; i++) codes['numpad '+i] = i + 96

	/**
	 * Get by code
	 *
	 *   exports.name[13] // => 'Enter'
	 */

	var names = exports.names = exports.title = {} // title for backward compat

	// Create reverse mapping
	for (i in codes) names[codes[i]] = i

	// Add aliases
	for (var alias in aliases) {
	  codes[alias] = aliases[alias]
	}


/***/ }
/******/ ]);