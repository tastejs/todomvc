webpackJsonp(1,{31:function(a,b,c){a.exports='#HTMLReporter{font-size:11px;font-family:Monaco,"Lucida Console",monospace;line-height:14px;color:#333}#HTMLReporter a{text-decoration:none}#HTMLReporter a:hover{text-decoration:underline}#HTMLReporter p,#HTMLReporter h1,#HTMLReporter h2,#HTMLReporter h3,#HTMLReporter h4,#HTMLReporter h5,#HTMLReporter h6{margin:0;line-height:14px}#HTMLReporter .banner,#HTMLReporter .symbolSummary,#HTMLReporter .summary,#HTMLReporter .resultMessage,#HTMLReporter .specDetail .description,#HTMLReporter .alert .bar,#HTMLReporter .stackTrace{padding-left:9px;padding-right:9px}#HTMLReporter #jasmine_content{position:fixed;right:100%}#HTMLReporter .version{color:#aaa}#HTMLReporter .banner{margin-top:14px}#HTMLReporter .duration{color:#aaa;float:right}#HTMLReporter .symbolSummary{overflow:hidden;*zoom:1;margin:14px 0}#HTMLReporter .symbolSummary li{display:block;float:left;height:7px;width:14px;margin-bottom:7px;font-size:16px}#HTMLReporter .symbolSummary li.passed{font-size:14px}#HTMLReporter .symbolSummary li.passed:before{color:#5e7d00;content:"\\02022"}#HTMLReporter .symbolSummary li.failed{line-height:9px}#HTMLReporter .symbolSummary li.failed:before{color:#b03911;content:"x";font-weight:700;margin-left:-1px}#HTMLReporter .symbolSummary li.skipped{font-size:14px}#HTMLReporter .symbolSummary li.skipped:before{color:#bababa;content:"\\02022"}#HTMLReporter .symbolSummary li.pending{line-height:11px}#HTMLReporter .symbolSummary li.pending:before{color:#aaa;content:"-"}#HTMLReporter .bar{line-height:28px;font-size:14px;display:block;color:#eee}#HTMLReporter .runningAlert{background-color:#666}#HTMLReporter .skippedAlert{background-color:#aaa}#HTMLReporter .skippedAlert:first-child{background-color:#333}#HTMLReporter .skippedAlert:hover{color:#fff;text-decoration:underline}#HTMLReporter .passingAlert{background-color:#a6b779}#HTMLReporter .passingAlert:first-child{background-color:#5e7d00}#HTMLReporter .failingAlert{background-color:#cf867e}#HTMLReporter .failingAlert:first-child{background-color:#b03911}#HTMLReporter .results{margin-top:14px}#HTMLReporter #details{display:none}#HTMLReporter .resultsMenu,#HTMLReporter .resultsMenu a{background-color:#fff;color:#333}#HTMLReporter.showDetails .summaryMenuItem{font-weight:400;text-decoration:inherit}#HTMLReporter.showDetails .summaryMenuItem:hover{text-decoration:underline}#HTMLReporter.showDetails .detailsMenuItem{font-weight:700;text-decoration:underline}#HTMLReporter.showDetails .summary{display:none}#HTMLReporter.showDetails #details{display:block}#HTMLReporter .summaryMenuItem{font-weight:700;text-decoration:underline}#HTMLReporter .summary{margin-top:14px}#HTMLReporter .summary .suite .suite,#HTMLReporter .summary .specSummary{margin-left:14px}#HTMLReporter .summary .specSummary.passed a{color:#5e7d00}#HTMLReporter .summary .specSummary.failed a{color:#b03911}#HTMLReporter .description+.suite{margin-top:0}#HTMLReporter .suite{margin-top:14px}#HTMLReporter .suite a{color:#333}#HTMLReporter #details .specDetail{margin-bottom:28px}#HTMLReporter #details .specDetail .description{display:block;color:#fff;background-color:#b03911}#HTMLReporter .resultMessage{padding-top:14px;color:#333}#HTMLReporter .resultMessage span.result{display:block}#HTMLReporter .stackTrace{margin:5px 0 0;max-height:224px;overflow:auto;line-height:18px;color:#666;border:1px solid #ddd;background:#fff;white-space:pre}#TrivialReporter{padding:8px 13px;position:absolute;top:0;bottom:0;left:0;right:0;overflow-y:scroll;background-color:#fff;font-family:"Helvetica Neue Light","Lucida Grande","Calibri","Arial",sans-serif}#TrivialReporter a:visited,#TrivialReporter a{color:#303}#TrivialReporter a:hover,#TrivialReporter a:active{color:#00f}#TrivialReporter .run_spec{float:right;padding-right:5px;font-size:.8em;text-decoration:none}#TrivialReporter .banner{color:#303;background-color:#fef;padding:5px}#TrivialReporter .logo{float:left;font-size:1.1em;padding-left:5px}#TrivialReporter .logo .version{font-size:.6em;padding-left:1em}#TrivialReporter .runner.running{background-color:#ff0}#TrivialReporter .options{text-align:right;font-size:.8em}#TrivialReporter .suite{border:1px outset gray;margin:5px 0;padding-left:1em}#TrivialReporter .suite .suite{margin:5px}#TrivialReporter .suite.passed{background-color:#dfd}#TrivialReporter .suite.failed{background-color:#fdd}#TrivialReporter .spec{margin:5px;padding-left:1em;clear:both}#TrivialReporter .spec.failed,#TrivialReporter .spec.passed,#TrivialReporter .spec.skipped{padding-bottom:5px;border:1px solid gray}#TrivialReporter .spec.failed{background-color:#fbb;border-color:red}#TrivialReporter .spec.passed{background-color:#bfb;border-color:green}#TrivialReporter .spec.skipped{background-color:#bbb}#TrivialReporter .messages{border-left:1px dashed gray;padding-left:1em;padding-right:1em}#TrivialReporter .passed{background-color:#cfc;display:none}#TrivialReporter .failed{background-color:#fbb}#TrivialReporter .skipped{color:#777;background-color:#eee;display:none}#TrivialReporter .resultMessage span.result{display:block;line-height:2em;color:#000}#TrivialReporter .resultMessage .mismatch{color:#000}#TrivialReporter .stackTrace{white-space:pre;font-size:.8em;margin-left:10px;max-height:5em;overflow:auto;border:1px inset red;padding:1em;background:#eef}#TrivialReporter .finished-at{padding-left:1em;font-size:.6em}#TrivialReporter.show-passed .passed,#TrivialReporter.show-skipped .skipped{display:block}#TrivialReporter #jasmine_content{position:fixed;right:100%}#TrivialReporter .runner{border:1px solid gray;display:block;margin:5px 0;padding:2px 0 2px 10px}'},32:function(a,b,c){a.exports="jasmine.HtmlReporterHelpers = {};\r\n\r\njasmine.HtmlReporterHelpers.createDom = function(type, attrs, childrenVarArgs) {\r\n  var el = document.createElement(type);\r\n\r\n  for (var i = 2; i < arguments.length; i++) {\r\n    var child = arguments[i];\r\n\r\n    if (typeof child === 'string') {\r\n      el.appendChild(document.createTextNode(child));\r\n    } else {\r\n      if (child) {\r\n        el.appendChild(child);\r\n      }\r\n    }\r\n  }\r\n\r\n  for (var attr in attrs) {\r\n    if (attr == \"className\") {\r\n      el[attr] = attrs[attr];\r\n    } else {\r\n      el.setAttribute(attr, attrs[attr]);\r\n    }\r\n  }\r\n\r\n  return el;\r\n};\r\n\r\njasmine.HtmlReporterHelpers.getSpecStatus = function(child) {\r\n  var results = child.results();\r\n  var status = results.passed() ? 'passed' : 'failed';\r\n  if (results.skipped) {\r\n    status = 'skipped';\r\n  }\r\n\r\n  return status;\r\n};\r\n\r\njasmine.HtmlReporterHelpers.appendToSummary = function(child, childElement) {\r\n  var parentDiv = this.dom.summary;\r\n  var parentSuite = (typeof child.parentSuite == 'undefined') ? 'suite' : 'parentSuite';\r\n  var parent = child[parentSuite];\r\n\r\n  if (parent) {\r\n    if (typeof this.views.suites[parent.id] == 'undefined') {\r\n      this.views.suites[parent.id] = new jasmine.HtmlReporter.SuiteView(parent, this.dom, this.views);\r\n    }\r\n    parentDiv = this.views.suites[parent.id].element;\r\n  }\r\n\r\n  parentDiv.appendChild(childElement);\r\n};\r\n\r\n\r\njasmine.HtmlReporterHelpers.addHelpers = function(ctor) {\r\n  for(var fn in jasmine.HtmlReporterHelpers) {\r\n    ctor.prototype[fn] = jasmine.HtmlReporterHelpers[fn];\r\n  }\r\n};\r\n\r\njasmine.HtmlReporter = function(_doc) {\r\n  var self = this;\r\n  var doc = _doc || window.document;\r\n\r\n  var reporterView;\r\n\r\n  var dom = {};\r\n\r\n  // Jasmine Reporter Public Interface\r\n  self.logRunningSpecs = false;\r\n\r\n  self.reportRunnerStarting = function(runner) {\r\n    var specs = runner.specs() || [];\r\n\r\n    if (specs.length == 0) {\r\n      return;\r\n    }\r\n\r\n    createReporterDom(runner.env.versionString());\r\n    doc.body.appendChild(dom.reporter);\r\n\r\n    reporterView = new jasmine.HtmlReporter.ReporterView(dom);\r\n    reporterView.addSpecs(specs, self.specFilter);\r\n  };\r\n\r\n  self.reportRunnerResults = function(runner) {\r\n    reporterView && reporterView.complete();\r\n  };\r\n\r\n  self.reportSuiteResults = function(suite) {\r\n    reporterView.suiteComplete(suite);\r\n  };\r\n\r\n  self.reportSpecStarting = function(spec) {\r\n    if (self.logRunningSpecs) {\r\n      self.log('>> Jasmine Running ' + spec.suite.description + ' ' + spec.description + '...');\r\n    }\r\n  };\r\n\r\n  self.reportSpecResults = function(spec) {\r\n    reporterView.specComplete(spec);\r\n  };\r\n\r\n  self.log = function() {\r\n    var console = jasmine.getGlobal().console;\r\n    if (console && console.log) {\r\n      if (console.log.apply) {\r\n        console.log.apply(console, arguments);\r\n      } else {\r\n        console.log(arguments); // ie fix: console.log.apply doesn't exist on ie\r\n      }\r\n    }\r\n  };\r\n\r\n  self.specFilter = function(spec) {\r\n    if (!focusedSpecName()) {\r\n      return true;\r\n    }\r\n\r\n    return spec.getFullName().indexOf(focusedSpecName()) === 0;\r\n  };\r\n\r\n  return self;\r\n\r\n  function focusedSpecName() {\r\n    var specName;\r\n\r\n    (function memoizeFocusedSpec() {\r\n      if (specName) {\r\n        return;\r\n      }\r\n\r\n      var paramMap = [];\r\n      var params = doc.location.search.substring(1).split('&');\r\n\r\n      for (var i = 0; i < params.length; i++) {\r\n        var p = params[i].split('=');\r\n        paramMap[decodeURIComponent(p[0])] = decodeURIComponent(p[1]);\r\n      }\r\n\r\n      specName = paramMap.spec;\r\n    })();\r\n\r\n    return specName;\r\n  }\r\n\r\n  function createReporterDom(version) {\r\n    dom.reporter = self.createDom('div', { id: 'HTMLReporter', className: 'jasmine_reporter' },\r\n      dom.banner = self.createDom('div', { className: 'banner' },\r\n        self.createDom('span', { className: 'title' }, \"Jasmine \"),\r\n        self.createDom('span', { className: 'version' }, version)),\r\n\r\n      dom.symbolSummary = self.createDom('ul', {className: 'symbolSummary'}),\r\n      dom.alert = self.createDom('div', {className: 'alert'}),\r\n      dom.results = self.createDom('div', {className: 'results'},\r\n        dom.summary = self.createDom('div', { className: 'summary' }),\r\n        dom.details = self.createDom('div', { id: 'details' }))\r\n    );\r\n  }\r\n};\r\njasmine.HtmlReporterHelpers.addHelpers(jasmine.HtmlReporter);jasmine.HtmlReporter.ReporterView = function(dom) {\r\n  this.startedAt = new Date();\r\n  this.runningSpecCount = 0;\r\n  this.completeSpecCount = 0;\r\n  this.passedCount = 0;\r\n  this.failedCount = 0;\r\n  this.skippedCount = 0;\r\n\r\n  this.createResultsMenu = function() {\r\n    this.resultsMenu = this.createDom('span', {className: 'resultsMenu bar'},\r\n      this.summaryMenuItem = this.createDom('a', {className: 'summaryMenuItem', href: \"#\"}, '0 specs'),\r\n      ' | ',\r\n      this.detailsMenuItem = this.createDom('a', {className: 'detailsMenuItem', href: \"#\"}, '0 failing'));\r\n\r\n    this.summaryMenuItem.onclick = function() {\r\n      dom.reporter.className = dom.reporter.className.replace(/ showDetails/g, '');\r\n    };\r\n\r\n    this.detailsMenuItem.onclick = function() {\r\n      showDetails();\r\n    };\r\n  };\r\n\r\n  this.addSpecs = function(specs, specFilter) {\r\n    this.totalSpecCount = specs.length;\r\n\r\n    this.views = {\r\n      specs: {},\r\n      suites: {}\r\n    };\r\n\r\n    for (var i = 0; i < specs.length; i++) {\r\n      var spec = specs[i];\r\n      this.views.specs[spec.id] = new jasmine.HtmlReporter.SpecView(spec, dom, this.views);\r\n      if (specFilter(spec)) {\r\n        this.runningSpecCount++;\r\n      }\r\n    }\r\n  };\r\n\r\n  this.specComplete = function(spec) {\r\n    this.completeSpecCount++;\r\n\r\n    if (isUndefined(this.views.specs[spec.id])) {\r\n      this.views.specs[spec.id] = new jasmine.HtmlReporter.SpecView(spec, dom);\r\n    }\r\n\r\n    var specView = this.views.specs[spec.id];\r\n\r\n    switch (specView.status()) {\r\n      case 'passed':\r\n        this.passedCount++;\r\n        break;\r\n\r\n      case 'failed':\r\n        this.failedCount++;\r\n        break;\r\n\r\n      case 'skipped':\r\n        this.skippedCount++;\r\n        break;\r\n    }\r\n\r\n    specView.refresh();\r\n    this.refresh();\r\n  };\r\n\r\n  this.suiteComplete = function(suite) {\r\n    var suiteView = this.views.suites[suite.id];\r\n    if (isUndefined(suiteView)) {\r\n      return;\r\n    }\r\n    suiteView.refresh();\r\n  };\r\n\r\n  this.refresh = function() {\r\n\r\n    if (isUndefined(this.resultsMenu)) {\r\n      this.createResultsMenu();\r\n    }\r\n\r\n    // currently running UI\r\n    if (isUndefined(this.runningAlert)) {\r\n      this.runningAlert = this.createDom('a', {href: \"?\", className: \"runningAlert bar\"});\r\n      dom.alert.appendChild(this.runningAlert);\r\n    }\r\n    this.runningAlert.innerHTML = \"Running \" + this.completeSpecCount + \" of \" + specPluralizedFor(this.totalSpecCount);\r\n\r\n    // skipped specs UI\r\n    if (isUndefined(this.skippedAlert)) {\r\n      this.skippedAlert = this.createDom('a', {href: \"?\", className: \"skippedAlert bar\"});\r\n    }\r\n\r\n    this.skippedAlert.innerHTML = \"Skipping \" + this.skippedCount + \" of \" + specPluralizedFor(this.totalSpecCount) + \" - run all\";\r\n\r\n    if (this.skippedCount === 1 && isDefined(dom.alert)) {\r\n      dom.alert.appendChild(this.skippedAlert);\r\n    }\r\n\r\n    // passing specs UI\r\n    if (isUndefined(this.passedAlert)) {\r\n      this.passedAlert = this.createDom('span', {href: \"?\", className: \"passingAlert bar\"});\r\n    }\r\n    this.passedAlert.innerHTML = \"Passing \" + specPluralizedFor(this.passedCount);\r\n\r\n    // failing specs UI\r\n    if (isUndefined(this.failedAlert)) {\r\n      this.failedAlert = this.createDom('span', {href: \"?\", className: \"failingAlert bar\"});\r\n    }\r\n    this.failedAlert.innerHTML = \"Failing \" + specPluralizedFor(this.failedCount);\r\n\r\n    if (this.failedCount === 1 && isDefined(dom.alert)) {\r\n      dom.alert.appendChild(this.failedAlert);\r\n      dom.alert.appendChild(this.resultsMenu);\r\n    }\r\n\r\n    // summary info\r\n    this.summaryMenuItem.innerHTML = \"\" + specPluralizedFor(this.runningSpecCount);\r\n    this.detailsMenuItem.innerHTML = \"\" + this.failedCount + \" failing\";\r\n  };\r\n\r\n  this.complete = function() {\r\n    dom.alert.removeChild(this.runningAlert);\r\n\r\n    this.skippedAlert.innerHTML = \"Ran \" + this.runningSpecCount + \" of \" + specPluralizedFor(this.totalSpecCount) + \" - run all\";\r\n\r\n    if (this.failedCount === 0) {\r\n      dom.alert.appendChild(this.createDom('span', {className: 'passingAlert bar'}, \"Passing \" + specPluralizedFor(this.passedCount)));\r\n    } else {\r\n      showDetails();\r\n    }\r\n\r\n    dom.banner.appendChild(this.createDom('span', {className: 'duration'}, \"finished in \" + ((new Date().getTime() - this.startedAt.getTime()) / 1000) + \"s\"));\r\n  };\r\n\r\n  return this;\r\n\r\n  function showDetails() {\r\n    if (dom.reporter.className.search(/showDetails/) === -1) {\r\n      dom.reporter.className += \" showDetails\";\r\n    }\r\n  }\r\n\r\n  function isUndefined(obj) {\r\n    return typeof obj === 'undefined';\r\n  }\r\n\r\n  function isDefined(obj) {\r\n    return !isUndefined(obj);\r\n  }\r\n\r\n  function specPluralizedFor(count) {\r\n    var str = count + \" spec\";\r\n    if (count > 1) {\r\n      str += \"s\"\r\n    }\r\n    return str;\r\n  }\r\n\r\n};\r\n\r\njasmine.HtmlReporterHelpers.addHelpers(jasmine.HtmlReporter.ReporterView);\r\n\r\n\r\njasmine.HtmlReporter.SpecView = function(spec, dom, views) {\r\n  this.spec = spec;\r\n  this.dom = dom;\r\n  this.views = views;\r\n\r\n  this.symbol = this.createDom('li', { className: 'pending' });\r\n  this.dom.symbolSummary.appendChild(this.symbol);\r\n\r\n  this.summary = this.createDom('div', { className: 'specSummary' },\r\n      this.createDom('a', {\r\n        className: 'description',\r\n        href: '?spec=' + encodeURIComponent(this.spec.getFullName()),\r\n        title: this.spec.getFullName()\r\n      }, this.spec.description)\r\n  );\r\n\r\n  this.detail = this.createDom('div', { className: 'specDetail' },\r\n      this.createDom('a', {\r\n        className: 'description',\r\n        href: '?spec=' + encodeURIComponent(this.spec.getFullName()),\r\n        title: this.spec.getFullName()\r\n      }, this.spec.getFullName())\r\n  );\r\n};\r\n\r\njasmine.HtmlReporter.SpecView.prototype.status = function() {\r\n  return this.getSpecStatus(this.spec);\r\n};\r\n\r\njasmine.HtmlReporter.SpecView.prototype.refresh = function() {\r\n  this.symbol.className = this.status();\r\n\r\n  switch (this.status()) {\r\n    case 'skipped':\r\n      break;\r\n\r\n    case 'passed':\r\n      this.appendSummaryToSuiteDiv();\r\n      break;\r\n\r\n    case 'failed':\r\n      this.appendSummaryToSuiteDiv();\r\n      this.appendFailureDetail();\r\n      break;\r\n  }\r\n};\r\n\r\njasmine.HtmlReporter.SpecView.prototype.appendSummaryToSuiteDiv = function() {\r\n  this.summary.className += ' ' + this.status();\r\n  this.appendToSummary(this.spec, this.summary);\r\n};\r\n\r\njasmine.HtmlReporter.SpecView.prototype.appendFailureDetail = function() {\r\n  this.detail.className += ' ' + this.status();\r\n\r\n  var resultItems = this.spec.results().getItems();\r\n  var messagesDiv = this.createDom('div', { className: 'messages' });\r\n\r\n  for (var i = 0; i < resultItems.length; i++) {\r\n    var result = resultItems[i];\r\n\r\n    if (result.type == 'log') {\r\n      messagesDiv.appendChild(this.createDom('div', {className: 'resultMessage log'}, result.toString()));\r\n    } else if (result.type == 'expect' && result.passed && !result.passed()) {\r\n      messagesDiv.appendChild(this.createDom('div', {className: 'resultMessage fail'}, result.message));\r\n\r\n      if (result.trace.stack) {\r\n        messagesDiv.appendChild(this.createDom('div', {className: 'stackTrace'}, result.trace.stack));\r\n      }\r\n    }\r\n  }\r\n\r\n  if (messagesDiv.childNodes.length > 0) {\r\n    this.detail.appendChild(messagesDiv);\r\n    this.dom.details.appendChild(this.detail);\r\n  }\r\n};\r\n\r\njasmine.HtmlReporterHelpers.addHelpers(jasmine.HtmlReporter.SpecView);jasmine.HtmlReporter.SuiteView = function(suite, dom, views) {\r\n  this.suite = suite;\r\n  this.dom = dom;\r\n  this.views = views;\r\n\r\n  this.element = this.createDom('div', { className: 'suite' },\r\n      this.createDom('a', { className: 'description', href: '?spec=' + encodeURIComponent(this.suite.getFullName()) }, this.suite.description)\r\n  );\r\n\r\n  this.appendToSummary(this.suite, this.element);\r\n};\r\n\r\njasmine.HtmlReporter.SuiteView.prototype.status = function() {\r\n  return this.getSpecStatus(this.suite);\r\n};\r\n\r\njasmine.HtmlReporter.SuiteView.prototype.refresh = function() {\r\n  this.element.className += \" \" + this.status();\r\n};\r\n\r\njasmine.HtmlReporterHelpers.addHelpers(jasmine.HtmlReporter.SuiteView);\r\n\r\n/* @deprecated Use jasmine.HtmlReporter instead\r\n */\r\njasmine.TrivialReporter = function(doc) {\r\n  this.document = doc || document;\r\n  this.suiteDivs = {};\r\n  this.logRunningSpecs = false;\r\n};\r\n\r\njasmine.TrivialReporter.prototype.createDom = function(type, attrs, childrenVarArgs) {\r\n  var el = document.createElement(type);\r\n\r\n  for (var i = 2; i < arguments.length; i++) {\r\n    var child = arguments[i];\r\n\r\n    if (typeof child === 'string') {\r\n      el.appendChild(document.createTextNode(child));\r\n    } else {\r\n      if (child) { el.appendChild(child); }\r\n    }\r\n  }\r\n\r\n  for (var attr in attrs) {\r\n    if (attr == \"className\") {\r\n      el[attr] = attrs[attr];\r\n    } else {\r\n      el.setAttribute(attr, attrs[attr]);\r\n    }\r\n  }\r\n\r\n  return el;\r\n};\r\n\r\njasmine.TrivialReporter.prototype.reportRunnerStarting = function(runner) {\r\n  var showPassed, showSkipped;\r\n\r\n  this.outerDiv = this.createDom('div', { id: 'TrivialReporter', className: 'jasmine_reporter' },\r\n      this.createDom('div', { className: 'banner' },\r\n        this.createDom('div', { className: 'logo' },\r\n            this.createDom('span', { className: 'title' }, \"Jasmine\"),\r\n            this.createDom('span', { className: 'version' }, runner.env.versionString())),\r\n        this.createDom('div', { className: 'options' },\r\n            \"Show \",\r\n            showPassed = this.createDom('input', { id: \"__jasmine_TrivialReporter_showPassed__\", type: 'checkbox' }),\r\n            this.createDom('label', { \"for\": \"__jasmine_TrivialReporter_showPassed__\" }, \" passed \"),\r\n            showSkipped = this.createDom('input', { id: \"__jasmine_TrivialReporter_showSkipped__\", type: 'checkbox' }),\r\n            this.createDom('label', { \"for\": \"__jasmine_TrivialReporter_showSkipped__\" }, \" skipped\")\r\n            )\r\n          ),\r\n\r\n      this.runnerDiv = this.createDom('div', { className: 'runner running' },\r\n          this.createDom('a', { className: 'run_spec', href: '?' }, \"run all\"),\r\n          this.runnerMessageSpan = this.createDom('span', {}, \"Running...\"),\r\n          this.finishedAtSpan = this.createDom('span', { className: 'finished-at' }, \"\"))\r\n      );\r\n\r\n  this.document.body.appendChild(this.outerDiv);\r\n\r\n  var suites = runner.suites();\r\n  for (var i = 0; i < suites.length; i++) {\r\n    var suite = suites[i];\r\n    var suiteDiv = this.createDom('div', { className: 'suite' },\r\n        this.createDom('a', { className: 'run_spec', href: '?spec=' + encodeURIComponent(suite.getFullName()) }, \"run\"),\r\n        this.createDom('a', { className: 'description', href: '?spec=' + encodeURIComponent(suite.getFullName()) }, suite.description));\r\n    this.suiteDivs[suite.id] = suiteDiv;\r\n    var parentDiv = this.outerDiv;\r\n    if (suite.parentSuite) {\r\n      parentDiv = this.suiteDivs[suite.parentSuite.id];\r\n    }\r\n    parentDiv.appendChild(suiteDiv);\r\n  }\r\n\r\n  this.startedAt = new Date();\r\n\r\n  var self = this;\r\n  showPassed.onclick = function(evt) {\r\n    if (showPassed.checked) {\r\n      self.outerDiv.className += ' show-passed';\r\n    } else {\r\n      self.outerDiv.className = self.outerDiv.className.replace(/ show-passed/, '');\r\n    }\r\n  };\r\n\r\n  showSkipped.onclick = function(evt) {\r\n    if (showSkipped.checked) {\r\n      self.outerDiv.className += ' show-skipped';\r\n    } else {\r\n      self.outerDiv.className = self.outerDiv.className.replace(/ show-skipped/, '');\r\n    }\r\n  };\r\n};\r\n\r\njasmine.TrivialReporter.prototype.reportRunnerResults = function(runner) {\r\n  var results = runner.results();\r\n  var className = (results.failedCount > 0) ? \"runner failed\" : \"runner passed\";\r\n  this.runnerDiv.setAttribute(\"class\", className);\r\n  //do it twice for IE\r\n  this.runnerDiv.setAttribute(\"className\", className);\r\n  var specs = runner.specs();\r\n  var specCount = 0;\r\n  for (var i = 0; i < specs.length; i++) {\r\n    if (this.specFilter(specs[i])) {\r\n      specCount++;\r\n    }\r\n  }\r\n  var message = \"\" + specCount + \" spec\" + (specCount == 1 ? \"\" : \"s\" ) + \", \" + results.failedCount + \" failure\" + ((results.failedCount == 1) ? \"\" : \"s\");\r\n  message += \" in \" + ((new Date().getTime() - this.startedAt.getTime()) / 1000) + \"s\";\r\n  this.runnerMessageSpan.replaceChild(this.createDom('a', { className: 'description', href: '?'}, message), this.runnerMessageSpan.firstChild);\r\n\r\n  this.finishedAtSpan.appendChild(document.createTextNode(\"Finished at \" + new Date().toString()));\r\n};\r\n\r\njasmine.TrivialReporter.prototype.reportSuiteResults = function(suite) {\r\n  var results = suite.results();\r\n  var status = results.passed() ? 'passed' : 'failed';\r\n  if (results.totalCount === 0) { // todo: change this to check results.skipped\r\n    status = 'skipped';\r\n  }\r\n  this.suiteDivs[suite.id].className += \" \" + status;\r\n};\r\n\r\njasmine.TrivialReporter.prototype.reportSpecStarting = function(spec) {\r\n  if (this.logRunningSpecs) {\r\n    this.log('>> Jasmine Running ' + spec.suite.description + ' ' + spec.description + '...');\r\n  }\r\n};\r\n\r\njasmine.TrivialReporter.prototype.reportSpecResults = function(spec) {\r\n  var results = spec.results();\r\n  var status = results.passed() ? 'passed' : 'failed';\r\n  if (results.skipped) {\r\n    status = 'skipped';\r\n  }\r\n  var specDiv = this.createDom('div', { className: 'spec '  + status },\r\n      this.createDom('a', { className: 'run_spec', href: '?spec=' + encodeURIComponent(spec.getFullName()) }, \"run\"),\r\n      this.createDom('a', {\r\n        className: 'description',\r\n        href: '?spec=' + encodeURIComponent(spec.getFullName()),\r\n        title: spec.getFullName()\r\n      }, spec.description));\r\n\r\n\r\n  var resultItems = results.getItems();\r\n  var messagesDiv = this.createDom('div', { className: 'messages' });\r\n  for (var i = 0; i < resultItems.length; i++) {\r\n    var result = resultItems[i];\r\n\r\n    if (result.type == 'log') {\r\n      messagesDiv.appendChild(this.createDom('div', {className: 'resultMessage log'}, result.toString()));\r\n    } else if (result.type == 'expect' && result.passed && !result.passed()) {\r\n      messagesDiv.appendChild(this.createDom('div', {className: 'resultMessage fail'}, result.message));\r\n\r\n      if (result.trace.stack) {\r\n        messagesDiv.appendChild(this.createDom('div', {className: 'stackTrace'}, result.trace.stack));\r\n      }\r\n    }\r\n  }\r\n\r\n  if (messagesDiv.childNodes.length > 0) {\r\n    specDiv.appendChild(messagesDiv);\r\n  }\r\n\r\n  this.suiteDivs[spec.suite.id].appendChild(specDiv);\r\n};\r\n\r\njasmine.TrivialReporter.prototype.log = function() {\r\n  var console = jasmine.getGlobal().console;\r\n  if (console && console.log) {\r\n    if (console.log.apply) {\r\n      console.log.apply(console, arguments);\r\n    } else {\r\n      console.log(arguments); // ie fix: console.log.apply doesn't exist on ie\r\n    }\r\n  }\r\n};\r\n\r\njasmine.TrivialReporter.prototype.getLocation = function() {\r\n  return this.document.location;\r\n};\r\n\r\njasmine.TrivialReporter.prototype.specFilter = function(spec) {\r\n  var paramMap = {};\r\n  var params = this.getLocation().search.substring(1).split('&');\r\n  for (var i = 0; i < params.length; i++) {\r\n    var p = params[i].split('=');\r\n    paramMap[decodeURIComponent(p[0])] = decodeURIComponent(p[1]);\r\n  }\r\n\r\n  if (!paramMap.spec) {\r\n    return true;\r\n  }\r\n  return spec.getFullName().indexOf(paramMap.spec) === 0;\r\n};\r\n"},33:function(a,b,c){a.exports="var isCommonJS = typeof window == \"undefined\";\r\n\r\n/**\r\n * Top level namespace for Jasmine, a lightweight JavaScript BDD/spec/testing framework.\r\n *\r\n * @namespace\r\n */\r\nvar jasmine = {};\r\nif (isCommonJS) exports.jasmine = jasmine;\r\n/**\r\n * @private\r\n */\r\njasmine.unimplementedMethod_ = function() {\r\n  throw new Error(\"unimplemented method\");\r\n};\r\n\r\n/**\r\n * Use <code>jasmine.undefined</code> instead of <code>undefined</code>, since <code>undefined</code> is just\r\n * a plain old variable and may be redefined by somebody else.\r\n *\r\n * @private\r\n */\r\njasmine.undefined = jasmine.___undefined___;\r\n\r\n/**\r\n * Show diagnostic messages in the console if set to true\r\n *\r\n */\r\njasmine.VERBOSE = false;\r\n\r\n/**\r\n * Default interval in milliseconds for event loop yields (e.g. to allow network activity or to refresh the screen with the HTML-based runner). Small values here may result in slow test running. Zero means no updates until all tests have completed.\r\n *\r\n */\r\njasmine.DEFAULT_UPDATE_INTERVAL = 250;\r\n\r\n/**\r\n * Default timeout interval in milliseconds for waitsFor() blocks.\r\n */\r\njasmine.DEFAULT_TIMEOUT_INTERVAL = 5000;\r\n\r\njasmine.getGlobal = function() {\r\n  function getGlobal() {\r\n    return this;\r\n  }\r\n\r\n  return getGlobal();\r\n};\r\n\r\n/**\r\n * Allows for bound functions to be compared.  Internal use only.\r\n *\r\n * @ignore\r\n * @private\r\n * @param base {Object} bound 'this' for the function\r\n * @param name {Function} function to find\r\n */\r\njasmine.bindOriginal_ = function(base, name) {\r\n  var original = base[name];\r\n  if (original.apply) {\r\n    return function() {\r\n      return original.apply(base, arguments);\r\n    };\r\n  } else {\r\n    // IE support\r\n    return jasmine.getGlobal()[name];\r\n  }\r\n};\r\n\r\njasmine.setTimeout = jasmine.bindOriginal_(jasmine.getGlobal(), 'setTimeout');\r\njasmine.clearTimeout = jasmine.bindOriginal_(jasmine.getGlobal(), 'clearTimeout');\r\njasmine.setInterval = jasmine.bindOriginal_(jasmine.getGlobal(), 'setInterval');\r\njasmine.clearInterval = jasmine.bindOriginal_(jasmine.getGlobal(), 'clearInterval');\r\n\r\njasmine.MessageResult = function(values) {\r\n  this.type = 'log';\r\n  this.values = values;\r\n  this.trace = new Error(); // todo: test better\r\n};\r\n\r\njasmine.MessageResult.prototype.toString = function() {\r\n  var text = \"\";\r\n  for (var i = 0; i < this.values.length; i++) {\r\n    if (i > 0) text += \" \";\r\n    if (jasmine.isString_(this.values[i])) {\r\n      text += this.values[i];\r\n    } else {\r\n      text += jasmine.pp(this.values[i]);\r\n    }\r\n  }\r\n  return text;\r\n};\r\n\r\njasmine.ExpectationResult = function(params) {\r\n  this.type = 'expect';\r\n  this.matcherName = params.matcherName;\r\n  this.passed_ = params.passed;\r\n  this.expected = params.expected;\r\n  this.actual = params.actual;\r\n  this.message = this.passed_ ? 'Passed.' : params.message;\r\n\r\n  var trace = (params.trace || new Error(this.message));\r\n  this.trace = this.passed_ ? '' : trace;\r\n};\r\n\r\njasmine.ExpectationResult.prototype.toString = function () {\r\n  return this.message;\r\n};\r\n\r\njasmine.ExpectationResult.prototype.passed = function () {\r\n  return this.passed_;\r\n};\r\n\r\n/**\r\n * Getter for the Jasmine environment. Ensures one gets created\r\n */\r\njasmine.getEnv = function() {\r\n  var env = jasmine.currentEnv_ = jasmine.currentEnv_ || new jasmine.Env();\r\n  return env;\r\n};\r\n\r\n/**\r\n * @ignore\r\n * @private\r\n * @param value\r\n * @returns {Boolean}\r\n */\r\njasmine.isArray_ = function(value) {\r\n  return jasmine.isA_(\"Array\", value);\r\n};\r\n\r\n/**\r\n * @ignore\r\n * @private\r\n * @param value\r\n * @returns {Boolean}\r\n */\r\njasmine.isString_ = function(value) {\r\n  return jasmine.isA_(\"String\", value);\r\n};\r\n\r\n/**\r\n * @ignore\r\n * @private\r\n * @param value\r\n * @returns {Boolean}\r\n */\r\njasmine.isNumber_ = function(value) {\r\n  return jasmine.isA_(\"Number\", value);\r\n};\r\n\r\n/**\r\n * @ignore\r\n * @private\r\n * @param {String} typeName\r\n * @param value\r\n * @returns {Boolean}\r\n */\r\njasmine.isA_ = function(typeName, value) {\r\n  return Object.prototype.toString.apply(value) === '[object ' + typeName + ']';\r\n};\r\n\r\n/**\r\n * Pretty printer for expecations.  Takes any object and turns it into a human-readable string.\r\n *\r\n * @param value {Object} an object to be outputted\r\n * @returns {String}\r\n */\r\njasmine.pp = function(value) {\r\n  var stringPrettyPrinter = new jasmine.StringPrettyPrinter();\r\n  stringPrettyPrinter.format(value);\r\n  return stringPrettyPrinter.string;\r\n};\r\n\r\n/**\r\n * Returns true if the object is a DOM Node.\r\n *\r\n * @param {Object} obj object to check\r\n * @returns {Boolean}\r\n */\r\njasmine.isDomNode = function(obj) {\r\n  return obj.nodeType > 0;\r\n};\r\n\r\n/**\r\n * Returns a matchable 'generic' object of the class type.  For use in expecations of type when values don't matter.\r\n *\r\n * @example\r\n * // don't care about which function is passed in, as long as it's a function\r\n * expect(mySpy).toHaveBeenCalledWith(jasmine.any(Function));\r\n *\r\n * @param {Class} clazz\r\n * @returns matchable object of the type clazz\r\n */\r\njasmine.any = function(clazz) {\r\n  return new jasmine.Matchers.Any(clazz);\r\n};\r\n\r\n/**\r\n * Returns a matchable subset of a JSON object. For use in expectations when you don't care about all of the\r\n * attributes on the object.\r\n *\r\n * @example\r\n * // don't care about any other attributes than foo.\r\n * expect(mySpy).toHaveBeenCalledWith(jasmine.objectContaining({foo: \"bar\"});\r\n *\r\n * @param sample {Object} sample\r\n * @returns matchable object for the sample\r\n */\r\njasmine.objectContaining = function (sample) {\r\n    return new jasmine.Matchers.ObjectContaining(sample);\r\n};\r\n\r\n/**\r\n * Jasmine Spies are test doubles that can act as stubs, spies, fakes or when used in an expecation, mocks.\r\n *\r\n * Spies should be created in test setup, before expectations.  They can then be checked, using the standard Jasmine\r\n * expectation syntax. Spies can be checked if they were called or not and what the calling params were.\r\n *\r\n * A Spy has the following fields: wasCalled, callCount, mostRecentCall, and argsForCall (see docs).\r\n *\r\n * Spies are torn down at the end of every spec.\r\n *\r\n * Note: Do <b>not</b> call new jasmine.Spy() directly - a spy must be created using spyOn, jasmine.createSpy or jasmine.createSpyObj.\r\n *\r\n * @example\r\n * // a stub\r\n * var myStub = jasmine.createSpy('myStub');  // can be used anywhere\r\n *\r\n * // spy example\r\n * var foo = {\r\n *   not: function(bool) { return !bool; }\r\n * }\r\n *\r\n * // actual foo.not will not be called, execution stops\r\n * spyOn(foo, 'not');\r\n\r\n // foo.not spied upon, execution will continue to implementation\r\n * spyOn(foo, 'not').andCallThrough();\r\n *\r\n * // fake example\r\n * var foo = {\r\n *   not: function(bool) { return !bool; }\r\n * }\r\n *\r\n * // foo.not(val) will return val\r\n * spyOn(foo, 'not').andCallFake(function(value) {return value;});\r\n *\r\n * // mock example\r\n * foo.not(7 == 7);\r\n * expect(foo.not).toHaveBeenCalled();\r\n * expect(foo.not).toHaveBeenCalledWith(true);\r\n *\r\n * @constructor\r\n * @see spyOn, jasmine.createSpy, jasmine.createSpyObj\r\n * @param {String} name\r\n */\r\njasmine.Spy = function(name) {\r\n  /**\r\n   * The name of the spy, if provided.\r\n   */\r\n  this.identity = name || 'unknown';\r\n  /**\r\n   *  Is this Object a spy?\r\n   */\r\n  this.isSpy = true;\r\n  /**\r\n   * The actual function this spy stubs.\r\n   */\r\n  this.plan = function() {\r\n  };\r\n  /**\r\n   * Tracking of the most recent call to the spy.\r\n   * @example\r\n   * var mySpy = jasmine.createSpy('foo');\r\n   * mySpy(1, 2);\r\n   * mySpy.mostRecentCall.args = [1, 2];\r\n   */\r\n  this.mostRecentCall = {};\r\n\r\n  /**\r\n   * Holds arguments for each call to the spy, indexed by call count\r\n   * @example\r\n   * var mySpy = jasmine.createSpy('foo');\r\n   * mySpy(1, 2);\r\n   * mySpy(7, 8);\r\n   * mySpy.mostRecentCall.args = [7, 8];\r\n   * mySpy.argsForCall[0] = [1, 2];\r\n   * mySpy.argsForCall[1] = [7, 8];\r\n   */\r\n  this.argsForCall = [];\r\n  this.calls = [];\r\n};\r\n\r\n/**\r\n * Tells a spy to call through to the actual implemenatation.\r\n *\r\n * @example\r\n * var foo = {\r\n *   bar: function() { // do some stuff }\r\n * }\r\n *\r\n * // defining a spy on an existing property: foo.bar\r\n * spyOn(foo, 'bar').andCallThrough();\r\n */\r\njasmine.Spy.prototype.andCallThrough = function() {\r\n  this.plan = this.originalValue;\r\n  return this;\r\n};\r\n\r\n/**\r\n * For setting the return value of a spy.\r\n *\r\n * @example\r\n * // defining a spy from scratch: foo() returns 'baz'\r\n * var foo = jasmine.createSpy('spy on foo').andReturn('baz');\r\n *\r\n * // defining a spy on an existing property: foo.bar() returns 'baz'\r\n * spyOn(foo, 'bar').andReturn('baz');\r\n *\r\n * @param {Object} value\r\n */\r\njasmine.Spy.prototype.andReturn = function(value) {\r\n  this.plan = function() {\r\n    return value;\r\n  };\r\n  return this;\r\n};\r\n\r\n/**\r\n * For throwing an exception when a spy is called.\r\n *\r\n * @example\r\n * // defining a spy from scratch: foo() throws an exception w/ message 'ouch'\r\n * var foo = jasmine.createSpy('spy on foo').andThrow('baz');\r\n *\r\n * // defining a spy on an existing property: foo.bar() throws an exception w/ message 'ouch'\r\n * spyOn(foo, 'bar').andThrow('baz');\r\n *\r\n * @param {String} exceptionMsg\r\n */\r\njasmine.Spy.prototype.andThrow = function(exceptionMsg) {\r\n  this.plan = function() {\r\n    throw exceptionMsg;\r\n  };\r\n  return this;\r\n};\r\n\r\n/**\r\n * Calls an alternate implementation when a spy is called.\r\n *\r\n * @example\r\n * var baz = function() {\r\n *   // do some stuff, return something\r\n * }\r\n * // defining a spy from scratch: foo() calls the function baz\r\n * var foo = jasmine.createSpy('spy on foo').andCall(baz);\r\n *\r\n * // defining a spy on an existing property: foo.bar() calls an anonymnous function\r\n * spyOn(foo, 'bar').andCall(function() { return 'baz';} );\r\n *\r\n * @param {Function} fakeFunc\r\n */\r\njasmine.Spy.prototype.andCallFake = function(fakeFunc) {\r\n  this.plan = fakeFunc;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Resets all of a spy's the tracking variables so that it can be used again.\r\n *\r\n * @example\r\n * spyOn(foo, 'bar');\r\n *\r\n * foo.bar();\r\n *\r\n * expect(foo.bar.callCount).toEqual(1);\r\n *\r\n * foo.bar.reset();\r\n *\r\n * expect(foo.bar.callCount).toEqual(0);\r\n */\r\njasmine.Spy.prototype.reset = function() {\r\n  this.wasCalled = false;\r\n  this.callCount = 0;\r\n  this.argsForCall = [];\r\n  this.calls = [];\r\n  this.mostRecentCall = {};\r\n};\r\n\r\njasmine.createSpy = function(name) {\r\n\r\n  var spyObj = function() {\r\n    spyObj.wasCalled = true;\r\n    spyObj.callCount++;\r\n    var args = jasmine.util.argsToArray(arguments);\r\n    spyObj.mostRecentCall.object = this;\r\n    spyObj.mostRecentCall.args = args;\r\n    spyObj.argsForCall.push(args);\r\n    spyObj.calls.push({object: this, args: args});\r\n    return spyObj.plan.apply(this, arguments);\r\n  };\r\n\r\n  var spy = new jasmine.Spy(name);\r\n\r\n  for (var prop in spy) {\r\n    spyObj[prop] = spy[prop];\r\n  }\r\n\r\n  spyObj.reset();\r\n\r\n  return spyObj;\r\n};\r\n\r\n/**\r\n * Determines whether an object is a spy.\r\n *\r\n * @param {jasmine.Spy|Object} putativeSpy\r\n * @returns {Boolean}\r\n */\r\njasmine.isSpy = function(putativeSpy) {\r\n  return putativeSpy && putativeSpy.isSpy;\r\n};\r\n\r\n/**\r\n * Creates a more complicated spy: an Object that has every property a function that is a spy.  Used for stubbing something\r\n * large in one call.\r\n *\r\n * @param {String} baseName name of spy class\r\n * @param {Array} methodNames array of names of methods to make spies\r\n */\r\njasmine.createSpyObj = function(baseName, methodNames) {\r\n  if (!jasmine.isArray_(methodNames) || methodNames.length === 0) {\r\n    throw new Error('createSpyObj requires a non-empty array of method names to create spies for');\r\n  }\r\n  var obj = {};\r\n  for (var i = 0; i < methodNames.length; i++) {\r\n    obj[methodNames[i]] = jasmine.createSpy(baseName + '.' + methodNames[i]);\r\n  }\r\n  return obj;\r\n};\r\n\r\n/**\r\n * All parameters are pretty-printed and concatenated together, then written to the current spec's output.\r\n *\r\n * Be careful not to leave calls to <code>jasmine.log</code> in production code.\r\n */\r\njasmine.log = function() {\r\n  var spec = jasmine.getEnv().currentSpec;\r\n  spec.log.apply(spec, arguments);\r\n};\r\n\r\n/**\r\n * Function that installs a spy on an existing object's method name.  Used within a Spec to create a spy.\r\n *\r\n * @example\r\n * // spy example\r\n * var foo = {\r\n *   not: function(bool) { return !bool; }\r\n * }\r\n * spyOn(foo, 'not'); // actual foo.not will not be called, execution stops\r\n *\r\n * @see jasmine.createSpy\r\n * @param obj\r\n * @param methodName\r\n * @returns a Jasmine spy that can be chained with all spy methods\r\n */\r\nvar spyOn = function(obj, methodName) {\r\n  return jasmine.getEnv().currentSpec.spyOn(obj, methodName);\r\n};\r\nif (isCommonJS) exports.spyOn = spyOn;\r\n\r\n/**\r\n * Creates a Jasmine spec that will be added to the current suite.\r\n *\r\n * // TODO: pending tests\r\n *\r\n * @example\r\n * it('should be true', function() {\r\n *   expect(true).toEqual(true);\r\n * });\r\n *\r\n * @param {String} desc description of this specification\r\n * @param {Function} func defines the preconditions and expectations of the spec\r\n */\r\nvar it = function(desc, func) {\r\n  return jasmine.getEnv().it(desc, func);\r\n};\r\nif (isCommonJS) exports.it = it;\r\n\r\n/**\r\n * Creates a <em>disabled</em> Jasmine spec.\r\n *\r\n * A convenience method that allows existing specs to be disabled temporarily during development.\r\n *\r\n * @param {String} desc description of this specification\r\n * @param {Function} func defines the preconditions and expectations of the spec\r\n */\r\nvar xit = function(desc, func) {\r\n  return jasmine.getEnv().xit(desc, func);\r\n};\r\nif (isCommonJS) exports.xit = xit;\r\n\r\n/**\r\n * Starts a chain for a Jasmine expectation.\r\n *\r\n * It is passed an Object that is the actual value and should chain to one of the many\r\n * jasmine.Matchers functions.\r\n *\r\n * @param {Object} actual Actual value to test against and expected value\r\n */\r\nvar expect = function(actual) {\r\n  return jasmine.getEnv().currentSpec.expect(actual);\r\n};\r\nif (isCommonJS) exports.expect = expect;\r\n\r\n/**\r\n * Defines part of a jasmine spec.  Used in cominbination with waits or waitsFor in asynchrnous specs.\r\n *\r\n * @param {Function} func Function that defines part of a jasmine spec.\r\n */\r\nvar runs = function(func) {\r\n  jasmine.getEnv().currentSpec.runs(func);\r\n};\r\nif (isCommonJS) exports.runs = runs;\r\n\r\n/**\r\n * Waits a fixed time period before moving to the next block.\r\n *\r\n * @deprecated Use waitsFor() instead\r\n * @param {Number} timeout milliseconds to wait\r\n */\r\nvar waits = function(timeout) {\r\n  jasmine.getEnv().currentSpec.waits(timeout);\r\n};\r\nif (isCommonJS) exports.waits = waits;\r\n\r\n/**\r\n * Waits for the latchFunction to return true before proceeding to the next block.\r\n *\r\n * @param {Function} latchFunction\r\n * @param {String} optional_timeoutMessage\r\n * @param {Number} optional_timeout\r\n */\r\nvar waitsFor = function(latchFunction, optional_timeoutMessage, optional_timeout) {\r\n  jasmine.getEnv().currentSpec.waitsFor.apply(jasmine.getEnv().currentSpec, arguments);\r\n};\r\nif (isCommonJS) exports.waitsFor = waitsFor;\r\n\r\n/**\r\n * A function that is called before each spec in a suite.\r\n *\r\n * Used for spec setup, including validating assumptions.\r\n *\r\n * @param {Function} beforeEachFunction\r\n */\r\nvar beforeEach = function(beforeEachFunction) {\r\n  jasmine.getEnv().beforeEach(beforeEachFunction);\r\n};\r\nif (isCommonJS) exports.beforeEach = beforeEach;\r\n\r\n/**\r\n * A function that is called after each spec in a suite.\r\n *\r\n * Used for restoring any state that is hijacked during spec execution.\r\n *\r\n * @param {Function} afterEachFunction\r\n */\r\nvar afterEach = function(afterEachFunction) {\r\n  jasmine.getEnv().afterEach(afterEachFunction);\r\n};\r\nif (isCommonJS) exports.afterEach = afterEach;\r\n\r\n/**\r\n * Defines a suite of specifications.\r\n *\r\n * Stores the description and all defined specs in the Jasmine environment as one suite of specs. Variables declared\r\n * are accessible by calls to beforeEach, it, and afterEach. Describe blocks can be nested, allowing for specialization\r\n * of setup in some tests.\r\n *\r\n * @example\r\n * // TODO: a simple suite\r\n *\r\n * // TODO: a simple suite with a nested describe block\r\n *\r\n * @param {String} description A string, usually the class under test.\r\n * @param {Function} specDefinitions function that defines several specs.\r\n */\r\nvar describe = function(description, specDefinitions) {\r\n  return jasmine.getEnv().describe(description, specDefinitions);\r\n};\r\nif (isCommonJS) exports.describe = describe;\r\n\r\n/**\r\n * Disables a suite of specifications.  Used to disable some suites in a file, or files, temporarily during development.\r\n *\r\n * @param {String} description A string, usually the class under test.\r\n * @param {Function} specDefinitions function that defines several specs.\r\n */\r\nvar xdescribe = function(description, specDefinitions) {\r\n  return jasmine.getEnv().xdescribe(description, specDefinitions);\r\n};\r\nif (isCommonJS) exports.xdescribe = xdescribe;\r\n\r\n\r\n// Provide the XMLHttpRequest class for IE 5.x-6.x:\r\njasmine.XmlHttpRequest = (typeof XMLHttpRequest == \"undefined\") ? function() {\r\n  function tryIt(f) {\r\n    try {\r\n      return f();\r\n    } catch(e) {\r\n    }\r\n    return null;\r\n  }\r\n\r\n  var xhr = tryIt(function() {\r\n    return new ActiveXObject(\"Msxml2.XMLHTTP.6.0\");\r\n  }) ||\r\n    tryIt(function() {\r\n      return new ActiveXObject(\"Msxml2.XMLHTTP.3.0\");\r\n    }) ||\r\n    tryIt(function() {\r\n      return new ActiveXObject(\"Msxml2.XMLHTTP\");\r\n    }) ||\r\n    tryIt(function() {\r\n      return new ActiveXObject(\"Microsoft.XMLHTTP\");\r\n    });\r\n\r\n  if (!xhr) throw new Error(\"This browser does not support XMLHttpRequest.\");\r\n\r\n  return xhr;\r\n} : XMLHttpRequest;\r\n/**\r\n * @namespace\r\n */\r\njasmine.util = {};\r\n\r\n/**\r\n * Declare that a child class inherit it's prototype from the parent class.\r\n *\r\n * @private\r\n * @param {Function} childClass\r\n * @param {Function} parentClass\r\n */\r\njasmine.util.inherit = function(childClass, parentClass) {\r\n  /**\r\n   * @private\r\n   */\r\n  var subclass = function() {\r\n  };\r\n  subclass.prototype = parentClass.prototype;\r\n  childClass.prototype = new subclass();\r\n};\r\n\r\njasmine.util.formatException = function(e) {\r\n  var lineNumber;\r\n  if (e.line) {\r\n    lineNumber = e.line;\r\n  }\r\n  else if (e.lineNumber) {\r\n    lineNumber = e.lineNumber;\r\n  }\r\n\r\n  var file;\r\n\r\n  if (e.sourceURL) {\r\n    file = e.sourceURL;\r\n  }\r\n  else if (e.fileName) {\r\n    file = e.fileName;\r\n  }\r\n\r\n  var message = (e.name && e.message) ? (e.name + ': ' + e.message) : e.toString();\r\n\r\n  if (file && lineNumber) {\r\n    message += ' in ' + file + ' (line ' + lineNumber + ')';\r\n  }\r\n\r\n  return message;\r\n};\r\n\r\njasmine.util.htmlEscape = function(str) {\r\n  if (!str) return str;\r\n  return str.replace(/&/g, '&amp;')\r\n    .replace(/</g, '&lt;')\r\n    .replace(/>/g, '&gt;');\r\n};\r\n\r\njasmine.util.argsToArray = function(args) {\r\n  var arrayOfArgs = [];\r\n  for (var i = 0; i < args.length; i++) arrayOfArgs.push(args[i]);\r\n  return arrayOfArgs;\r\n};\r\n\r\njasmine.util.extend = function(destination, source) {\r\n  for (var property in source) destination[property] = source[property];\r\n  return destination;\r\n};\r\n\r\n/**\r\n * Environment for Jasmine\r\n *\r\n * @constructor\r\n */\r\njasmine.Env = function() {\r\n  this.currentSpec = null;\r\n  this.currentSuite = null;\r\n  this.currentRunner_ = new jasmine.Runner(this);\r\n\r\n  this.reporter = new jasmine.MultiReporter();\r\n\r\n  this.updateInterval = jasmine.DEFAULT_UPDATE_INTERVAL;\r\n  this.defaultTimeoutInterval = jasmine.DEFAULT_TIMEOUT_INTERVAL;\r\n  this.lastUpdate = 0;\r\n  this.specFilter = function() {\r\n    return true;\r\n  };\r\n\r\n  this.nextSpecId_ = 0;\r\n  this.nextSuiteId_ = 0;\r\n  this.equalityTesters_ = [];\r\n\r\n  // wrap matchers\r\n  this.matchersClass = function() {\r\n    jasmine.Matchers.apply(this, arguments);\r\n  };\r\n  jasmine.util.inherit(this.matchersClass, jasmine.Matchers);\r\n\r\n  jasmine.Matchers.wrapInto_(jasmine.Matchers.prototype, this.matchersClass);\r\n};\r\n\r\n\r\njasmine.Env.prototype.setTimeout = jasmine.setTimeout;\r\njasmine.Env.prototype.clearTimeout = jasmine.clearTimeout;\r\njasmine.Env.prototype.setInterval = jasmine.setInterval;\r\njasmine.Env.prototype.clearInterval = jasmine.clearInterval;\r\n\r\n/**\r\n * @returns an object containing jasmine version build info, if set.\r\n */\r\njasmine.Env.prototype.version = function () {\r\n  if (jasmine.version_) {\r\n    return jasmine.version_;\r\n  } else {\r\n    throw new Error('Version not set');\r\n  }\r\n};\r\n\r\n/**\r\n * @returns string containing jasmine version build info, if set.\r\n */\r\njasmine.Env.prototype.versionString = function() {\r\n  if (!jasmine.version_) {\r\n    return \"version unknown\";\r\n  }\r\n\r\n  var version = this.version();\r\n  var versionString = version.major + \".\" + version.minor + \".\" + version.build;\r\n  if (version.release_candidate) {\r\n    versionString += \".rc\" + version.release_candidate;\r\n  }\r\n  versionString += \" revision \" + version.revision;\r\n  return versionString;\r\n};\r\n\r\n/**\r\n * @returns a sequential integer starting at 0\r\n */\r\njasmine.Env.prototype.nextSpecId = function () {\r\n  return this.nextSpecId_++;\r\n};\r\n\r\n/**\r\n * @returns a sequential integer starting at 0\r\n */\r\njasmine.Env.prototype.nextSuiteId = function () {\r\n  return this.nextSuiteId_++;\r\n};\r\n\r\n/**\r\n * Register a reporter to receive status updates from Jasmine.\r\n * @param {jasmine.Reporter} reporter An object which will receive status updates.\r\n */\r\njasmine.Env.prototype.addReporter = function(reporter) {\r\n  this.reporter.addReporter(reporter);\r\n};\r\n\r\njasmine.Env.prototype.execute = function() {\r\n  this.currentRunner_.execute();\r\n};\r\n\r\njasmine.Env.prototype.describe = function(description, specDefinitions) {\r\n  var suite = new jasmine.Suite(this, description, specDefinitions, this.currentSuite);\r\n\r\n  var parentSuite = this.currentSuite;\r\n  if (parentSuite) {\r\n    parentSuite.add(suite);\r\n  } else {\r\n    this.currentRunner_.add(suite);\r\n  }\r\n\r\n  this.currentSuite = suite;\r\n\r\n  var declarationError = null;\r\n  try {\r\n    specDefinitions.call(suite);\r\n  } catch(e) {\r\n    declarationError = e;\r\n  }\r\n\r\n  if (declarationError) {\r\n    this.it(\"encountered a declaration exception\", function() {\r\n      throw declarationError;\r\n    });\r\n  }\r\n\r\n  this.currentSuite = parentSuite;\r\n\r\n  return suite;\r\n};\r\n\r\njasmine.Env.prototype.beforeEach = function(beforeEachFunction) {\r\n  if (this.currentSuite) {\r\n    this.currentSuite.beforeEach(beforeEachFunction);\r\n  } else {\r\n    this.currentRunner_.beforeEach(beforeEachFunction);\r\n  }\r\n};\r\n\r\njasmine.Env.prototype.currentRunner = function () {\r\n  return this.currentRunner_;\r\n};\r\n\r\njasmine.Env.prototype.afterEach = function(afterEachFunction) {\r\n  if (this.currentSuite) {\r\n    this.currentSuite.afterEach(afterEachFunction);\r\n  } else {\r\n    this.currentRunner_.afterEach(afterEachFunction);\r\n  }\r\n\r\n};\r\n\r\njasmine.Env.prototype.xdescribe = function(desc, specDefinitions) {\r\n  return {\r\n    execute: function() {\r\n    }\r\n  };\r\n};\r\n\r\njasmine.Env.prototype.it = function(description, func) {\r\n  var spec = new jasmine.Spec(this, this.currentSuite, description);\r\n  this.currentSuite.add(spec);\r\n  this.currentSpec = spec;\r\n\r\n  if (func) {\r\n    spec.runs(func);\r\n  }\r\n\r\n  return spec;\r\n};\r\n\r\njasmine.Env.prototype.xit = function(desc, func) {\r\n  return {\r\n    id: this.nextSpecId(),\r\n    runs: function() {\r\n    }\r\n  };\r\n};\r\n\r\njasmine.Env.prototype.compareObjects_ = function(a, b, mismatchKeys, mismatchValues) {\r\n  if (a.__Jasmine_been_here_before__ === b && b.__Jasmine_been_here_before__ === a) {\r\n    return true;\r\n  }\r\n\r\n  a.__Jasmine_been_here_before__ = b;\r\n  b.__Jasmine_been_here_before__ = a;\r\n\r\n  var hasKey = function(obj, keyName) {\r\n    return obj !== null && obj[keyName] !== jasmine.undefined;\r\n  };\r\n\r\n  for (var property in b) {\r\n    if (!hasKey(a, property) && hasKey(b, property)) {\r\n      mismatchKeys.push(\"expected has key '\" + property + \"', but missing from actual.\");\r\n    }\r\n  }\r\n  for (property in a) {\r\n    if (!hasKey(b, property) && hasKey(a, property)) {\r\n      mismatchKeys.push(\"expected missing key '\" + property + \"', but present in actual.\");\r\n    }\r\n  }\r\n  for (property in b) {\r\n    if (property == '__Jasmine_been_here_before__') continue;\r\n    if (!this.equals_(a[property], b[property], mismatchKeys, mismatchValues)) {\r\n      mismatchValues.push(\"'\" + property + \"' was '\" + (b[property] ? jasmine.util.htmlEscape(b[property].toString()) : b[property]) + \"' in expected, but was '\" + (a[property] ? jasmine.util.htmlEscape(a[property].toString()) : a[property]) + \"' in actual.\");\r\n    }\r\n  }\r\n\r\n  if (jasmine.isArray_(a) && jasmine.isArray_(b) && a.length != b.length) {\r\n    mismatchValues.push(\"arrays were not the same length\");\r\n  }\r\n\r\n  delete a.__Jasmine_been_here_before__;\r\n  delete b.__Jasmine_been_here_before__;\r\n  return (mismatchKeys.length === 0 && mismatchValues.length === 0);\r\n};\r\n\r\njasmine.Env.prototype.equals_ = function(a, b, mismatchKeys, mismatchValues) {\r\n  mismatchKeys = mismatchKeys || [];\r\n  mismatchValues = mismatchValues || [];\r\n\r\n  for (var i = 0; i < this.equalityTesters_.length; i++) {\r\n    var equalityTester = this.equalityTesters_[i];\r\n    var result = equalityTester(a, b, this, mismatchKeys, mismatchValues);\r\n    if (result !== jasmine.undefined) return result;\r\n  }\r\n\r\n  if (a === b) return true;\r\n\r\n  if (a === jasmine.undefined || a === null || b === jasmine.undefined || b === null) {\r\n    return (a == jasmine.undefined && b == jasmine.undefined);\r\n  }\r\n\r\n  if (jasmine.isDomNode(a) && jasmine.isDomNode(b)) {\r\n    return a === b;\r\n  }\r\n\r\n  if (a instanceof Date && b instanceof Date) {\r\n    return a.getTime() == b.getTime();\r\n  }\r\n\r\n  if (a.jasmineMatches) {\r\n    return a.jasmineMatches(b);\r\n  }\r\n\r\n  if (b.jasmineMatches) {\r\n    return b.jasmineMatches(a);\r\n  }\r\n\r\n  if (a instanceof jasmine.Matchers.ObjectContaining) {\r\n    return a.matches(b);\r\n  }\r\n\r\n  if (b instanceof jasmine.Matchers.ObjectContaining) {\r\n    return b.matches(a);\r\n  }\r\n\r\n  if (jasmine.isString_(a) && jasmine.isString_(b)) {\r\n    return (a == b);\r\n  }\r\n\r\n  if (jasmine.isNumber_(a) && jasmine.isNumber_(b)) {\r\n    return (a == b);\r\n  }\r\n\r\n  if (typeof a === \"object\" && typeof b === \"object\") {\r\n    return this.compareObjects_(a, b, mismatchKeys, mismatchValues);\r\n  }\r\n\r\n  //Straight check\r\n  return (a === b);\r\n};\r\n\r\njasmine.Env.prototype.contains_ = function(haystack, needle) {\r\n  if (jasmine.isArray_(haystack)) {\r\n    for (var i = 0; i < haystack.length; i++) {\r\n      if (this.equals_(haystack[i], needle)) return true;\r\n    }\r\n    return false;\r\n  }\r\n  return haystack.indexOf(needle) >= 0;\r\n};\r\n\r\njasmine.Env.prototype.addEqualityTester = function(equalityTester) {\r\n  this.equalityTesters_.push(equalityTester);\r\n};\r\n/** No-op base class for Jasmine reporters.\r\n *\r\n * @constructor\r\n */\r\njasmine.Reporter = function() {\r\n};\r\n\r\n//noinspection JSUnusedLocalSymbols\r\njasmine.Reporter.prototype.reportRunnerStarting = function(runner) {\r\n};\r\n\r\n//noinspection JSUnusedLocalSymbols\r\njasmine.Reporter.prototype.reportRunnerResults = function(runner) {\r\n};\r\n\r\n//noinspection JSUnusedLocalSymbols\r\njasmine.Reporter.prototype.reportSuiteResults = function(suite) {\r\n};\r\n\r\n//noinspection JSUnusedLocalSymbols\r\njasmine.Reporter.prototype.reportSpecStarting = function(spec) {\r\n};\r\n\r\n//noinspection JSUnusedLocalSymbols\r\njasmine.Reporter.prototype.reportSpecResults = function(spec) {\r\n};\r\n\r\n//noinspection JSUnusedLocalSymbols\r\njasmine.Reporter.prototype.log = function(str) {\r\n};\r\n\r\n/**\r\n * Blocks are functions with executable code that make up a spec.\r\n *\r\n * @constructor\r\n * @param {jasmine.Env} env\r\n * @param {Function} func\r\n * @param {jasmine.Spec} spec\r\n */\r\njasmine.Block = function(env, func, spec) {\r\n  this.env = env;\r\n  this.func = func;\r\n  this.spec = spec;\r\n};\r\n\r\njasmine.Block.prototype.execute = function(onComplete) {  \r\n  try {\r\n    this.func.apply(this.spec);\r\n  } catch (e) {\r\n    this.spec.fail(e);\r\n  }\r\n  onComplete();\r\n};\r\n/** JavaScript API reporter.\r\n *\r\n * @constructor\r\n */\r\njasmine.JsApiReporter = function() {\r\n  this.started = false;\r\n  this.finished = false;\r\n  this.suites_ = [];\r\n  this.results_ = {};\r\n};\r\n\r\njasmine.JsApiReporter.prototype.reportRunnerStarting = function(runner) {\r\n  this.started = true;\r\n  var suites = runner.topLevelSuites();\r\n  for (var i = 0; i < suites.length; i++) {\r\n    var suite = suites[i];\r\n    this.suites_.push(this.summarize_(suite));\r\n  }\r\n};\r\n\r\njasmine.JsApiReporter.prototype.suites = function() {\r\n  return this.suites_;\r\n};\r\n\r\njasmine.JsApiReporter.prototype.summarize_ = function(suiteOrSpec) {\r\n  var isSuite = suiteOrSpec instanceof jasmine.Suite;\r\n  var summary = {\r\n    id: suiteOrSpec.id,\r\n    name: suiteOrSpec.description,\r\n    type: isSuite ? 'suite' : 'spec',\r\n    children: []\r\n  };\r\n  \r\n  if (isSuite) {\r\n    var children = suiteOrSpec.children();\r\n    for (var i = 0; i < children.length; i++) {\r\n      summary.children.push(this.summarize_(children[i]));\r\n    }\r\n  }\r\n  return summary;\r\n};\r\n\r\njasmine.JsApiReporter.prototype.results = function() {\r\n  return this.results_;\r\n};\r\n\r\njasmine.JsApiReporter.prototype.resultsForSpec = function(specId) {\r\n  return this.results_[specId];\r\n};\r\n\r\n//noinspection JSUnusedLocalSymbols\r\njasmine.JsApiReporter.prototype.reportRunnerResults = function(runner) {\r\n  this.finished = true;\r\n};\r\n\r\n//noinspection JSUnusedLocalSymbols\r\njasmine.JsApiReporter.prototype.reportSuiteResults = function(suite) {\r\n};\r\n\r\n//noinspection JSUnusedLocalSymbols\r\njasmine.JsApiReporter.prototype.reportSpecResults = function(spec) {\r\n  this.results_[spec.id] = {\r\n    messages: spec.results().getItems(),\r\n    result: spec.results().failedCount > 0 ? \"failed\" : \"passed\"\r\n  };\r\n};\r\n\r\n//noinspection JSUnusedLocalSymbols\r\njasmine.JsApiReporter.prototype.log = function(str) {\r\n};\r\n\r\njasmine.JsApiReporter.prototype.resultsForSpecs = function(specIds){\r\n  var results = {};\r\n  for (var i = 0; i < specIds.length; i++) {\r\n    var specId = specIds[i];\r\n    results[specId] = this.summarizeResult_(this.results_[specId]);\r\n  }\r\n  return results;\r\n};\r\n\r\njasmine.JsApiReporter.prototype.summarizeResult_ = function(result){\r\n  var summaryMessages = [];\r\n  var messagesLength = result.messages.length;\r\n  for (var messageIndex = 0; messageIndex < messagesLength; messageIndex++) {\r\n    var resultMessage = result.messages[messageIndex];\r\n    summaryMessages.push({\r\n      text: resultMessage.type == 'log' ? resultMessage.toString() : jasmine.undefined,\r\n      passed: resultMessage.passed ? resultMessage.passed() : true,\r\n      type: resultMessage.type,\r\n      message: resultMessage.message,\r\n      trace: {\r\n        stack: resultMessage.passed && !resultMessage.passed() ? resultMessage.trace.stack : jasmine.undefined\r\n      }\r\n    });\r\n  }\r\n\r\n  return {\r\n    result : result.result,\r\n    messages : summaryMessages\r\n  };\r\n};\r\n\r\n/**\r\n * @constructor\r\n * @param {jasmine.Env} env\r\n * @param actual\r\n * @param {jasmine.Spec} spec\r\n */\r\njasmine.Matchers = function(env, actual, spec, opt_isNot) {\r\n  this.env = env;\r\n  this.actual = actual;\r\n  this.spec = spec;\r\n  this.isNot = opt_isNot || false;\r\n  this.reportWasCalled_ = false;\r\n};\r\n\r\n// todo: @deprecated as of Jasmine 0.11, remove soon [xw]\r\njasmine.Matchers.pp = function(str) {\r\n  throw new Error(\"jasmine.Matchers.pp() is no longer supported, please use jasmine.pp() instead!\");\r\n};\r\n\r\n// todo: @deprecated Deprecated as of Jasmine 0.10. Rewrite your custom matchers to return true or false. [xw]\r\njasmine.Matchers.prototype.report = function(result, failing_message, details) {\r\n  throw new Error(\"As of jasmine 0.11, custom matchers must be implemented differently -- please see jasmine docs\");\r\n};\r\n\r\njasmine.Matchers.wrapInto_ = function(prototype, matchersClass) {\r\n  for (var methodName in prototype) {\r\n    if (methodName == 'report') continue;\r\n    var orig = prototype[methodName];\r\n    matchersClass.prototype[methodName] = jasmine.Matchers.matcherFn_(methodName, orig);\r\n  }\r\n};\r\n\r\njasmine.Matchers.matcherFn_ = function(matcherName, matcherFunction) {\r\n  return function() {\r\n    var matcherArgs = jasmine.util.argsToArray(arguments);\r\n    var result = matcherFunction.apply(this, arguments);\r\n\r\n    if (this.isNot) {\r\n      result = !result;\r\n    }\r\n\r\n    if (this.reportWasCalled_) return result;\r\n\r\n    var message;\r\n    if (!result) {\r\n      if (this.message) {\r\n        message = this.message.apply(this, arguments);\r\n        if (jasmine.isArray_(message)) {\r\n          message = message[this.isNot ? 1 : 0];\r\n        }\r\n      } else {\r\n        var englishyPredicate = matcherName.replace(/[A-Z]/g, function(s) { return ' ' + s.toLowerCase(); });\r\n        message = \"Expected \" + jasmine.pp(this.actual) + (this.isNot ? \" not \" : \" \") + englishyPredicate;\r\n        if (matcherArgs.length > 0) {\r\n          for (var i = 0; i < matcherArgs.length; i++) {\r\n            if (i > 0) message += \",\";\r\n            message += \" \" + jasmine.pp(matcherArgs[i]);\r\n          }\r\n        }\r\n        message += \".\";\r\n      }\r\n    }\r\n    var expectationResult = new jasmine.ExpectationResult({\r\n      matcherName: matcherName,\r\n      passed: result,\r\n      expected: matcherArgs.length > 1 ? matcherArgs : matcherArgs[0],\r\n      actual: this.actual,\r\n      message: message\r\n    });\r\n    this.spec.addMatcherResult(expectationResult);\r\n    return jasmine.undefined;\r\n  };\r\n};\r\n\r\n\r\n\r\n\r\n/**\r\n * toBe: compares the actual to the expected using ===\r\n * @param expected\r\n */\r\njasmine.Matchers.prototype.toBe = function(expected) {\r\n  return this.actual === expected;\r\n};\r\n\r\n/**\r\n * toNotBe: compares the actual to the expected using !==\r\n * @param expected\r\n * @deprecated as of 1.0. Use not.toBe() instead.\r\n */\r\njasmine.Matchers.prototype.toNotBe = function(expected) {\r\n  return this.actual !== expected;\r\n};\r\n\r\n/**\r\n * toEqual: compares the actual to the expected using common sense equality. Handles Objects, Arrays, etc.\r\n *\r\n * @param expected\r\n */\r\njasmine.Matchers.prototype.toEqual = function(expected) {\r\n  return this.env.equals_(this.actual, expected);\r\n};\r\n\r\n/**\r\n * toNotEqual: compares the actual to the expected using the ! of jasmine.Matchers.toEqual\r\n * @param expected\r\n * @deprecated as of 1.0. Use not.toEqual() instead.\r\n */\r\njasmine.Matchers.prototype.toNotEqual = function(expected) {\r\n  return !this.env.equals_(this.actual, expected);\r\n};\r\n\r\n/**\r\n * Matcher that compares the actual to the expected using a regular expression.  Constructs a RegExp, so takes\r\n * a pattern or a String.\r\n *\r\n * @param expected\r\n */\r\njasmine.Matchers.prototype.toMatch = function(expected) {\r\n  return new RegExp(expected).test(this.actual);\r\n};\r\n\r\n/**\r\n * Matcher that compares the actual to the expected using the boolean inverse of jasmine.Matchers.toMatch\r\n * @param expected\r\n * @deprecated as of 1.0. Use not.toMatch() instead.\r\n */\r\njasmine.Matchers.prototype.toNotMatch = function(expected) {\r\n  return !(new RegExp(expected).test(this.actual));\r\n};\r\n\r\n/**\r\n * Matcher that compares the actual to jasmine.undefined.\r\n */\r\njasmine.Matchers.prototype.toBeDefined = function() {\r\n  return (this.actual !== jasmine.undefined);\r\n};\r\n\r\n/**\r\n * Matcher that compares the actual to jasmine.undefined.\r\n */\r\njasmine.Matchers.prototype.toBeUndefined = function() {\r\n  return (this.actual === jasmine.undefined);\r\n};\r\n\r\n/**\r\n * Matcher that compares the actual to null.\r\n */\r\njasmine.Matchers.prototype.toBeNull = function() {\r\n  return (this.actual === null);\r\n};\r\n\r\n/**\r\n * Matcher that boolean not-nots the actual.\r\n */\r\njasmine.Matchers.prototype.toBeTruthy = function() {\r\n  return !!this.actual;\r\n};\r\n\r\n\r\n/**\r\n * Matcher that boolean nots the actual.\r\n */\r\njasmine.Matchers.prototype.toBeFalsy = function() {\r\n  return !this.actual;\r\n};\r\n\r\n\r\n/**\r\n * Matcher that checks to see if the actual, a Jasmine spy, was called.\r\n */\r\njasmine.Matchers.prototype.toHaveBeenCalled = function() {\r\n  if (arguments.length > 0) {\r\n    throw new Error('toHaveBeenCalled does not take arguments, use toHaveBeenCalledWith');\r\n  }\r\n\r\n  if (!jasmine.isSpy(this.actual)) {\r\n    throw new Error('Expected a spy, but got ' + jasmine.pp(this.actual) + '.');\r\n  }\r\n\r\n  this.message = function() {\r\n    return [\r\n      \"Expected spy \" + this.actual.identity + \" to have been called.\",\r\n      \"Expected spy \" + this.actual.identity + \" not to have been called.\"\r\n    ];\r\n  };\r\n\r\n  return this.actual.wasCalled;\r\n};\r\n\r\n/** @deprecated Use expect(xxx).toHaveBeenCalled() instead */\r\njasmine.Matchers.prototype.wasCalled = jasmine.Matchers.prototype.toHaveBeenCalled;\r\n\r\n/**\r\n * Matcher that checks to see if the actual, a Jasmine spy, was not called.\r\n *\r\n * @deprecated Use expect(xxx).not.toHaveBeenCalled() instead\r\n */\r\njasmine.Matchers.prototype.wasNotCalled = function() {\r\n  if (arguments.length > 0) {\r\n    throw new Error('wasNotCalled does not take arguments');\r\n  }\r\n\r\n  if (!jasmine.isSpy(this.actual)) {\r\n    throw new Error('Expected a spy, but got ' + jasmine.pp(this.actual) + '.');\r\n  }\r\n\r\n  this.message = function() {\r\n    return [\r\n      \"Expected spy \" + this.actual.identity + \" to not have been called.\",\r\n      \"Expected spy \" + this.actual.identity + \" to have been called.\"\r\n    ];\r\n  };\r\n\r\n  return !this.actual.wasCalled;\r\n};\r\n\r\n/**\r\n * Matcher that checks to see if the actual, a Jasmine spy, was called with a set of parameters.\r\n *\r\n * @example\r\n *\r\n */\r\njasmine.Matchers.prototype.toHaveBeenCalledWith = function() {\r\n  var expectedArgs = jasmine.util.argsToArray(arguments);\r\n  if (!jasmine.isSpy(this.actual)) {\r\n    throw new Error('Expected a spy, but got ' + jasmine.pp(this.actual) + '.');\r\n  }\r\n  this.message = function() {\r\n    if (this.actual.callCount === 0) {\r\n      // todo: what should the failure message for .not.toHaveBeenCalledWith() be? is this right? test better. [xw]\r\n      return [\r\n        \"Expected spy \" + this.actual.identity + \" to have been called with \" + jasmine.pp(expectedArgs) + \" but it was never called.\",\r\n        \"Expected spy \" + this.actual.identity + \" not to have been called with \" + jasmine.pp(expectedArgs) + \" but it was.\"\r\n      ];\r\n    } else {\r\n      return [\r\n        \"Expected spy \" + this.actual.identity + \" to have been called with \" + jasmine.pp(expectedArgs) + \" but was called with \" + jasmine.pp(this.actual.argsForCall),\r\n        \"Expected spy \" + this.actual.identity + \" not to have been called with \" + jasmine.pp(expectedArgs) + \" but was called with \" + jasmine.pp(this.actual.argsForCall)\r\n      ];\r\n    }\r\n  };\r\n\r\n  return this.env.contains_(this.actual.argsForCall, expectedArgs);\r\n};\r\n\r\n/** @deprecated Use expect(xxx).toHaveBeenCalledWith() instead */\r\njasmine.Matchers.prototype.wasCalledWith = jasmine.Matchers.prototype.toHaveBeenCalledWith;\r\n\r\n/** @deprecated Use expect(xxx).not.toHaveBeenCalledWith() instead */\r\njasmine.Matchers.prototype.wasNotCalledWith = function() {\r\n  var expectedArgs = jasmine.util.argsToArray(arguments);\r\n  if (!jasmine.isSpy(this.actual)) {\r\n    throw new Error('Expected a spy, but got ' + jasmine.pp(this.actual) + '.');\r\n  }\r\n\r\n  this.message = function() {\r\n    return [\r\n      \"Expected spy not to have been called with \" + jasmine.pp(expectedArgs) + \" but it was\",\r\n      \"Expected spy to have been called with \" + jasmine.pp(expectedArgs) + \" but it was\"\r\n    ];\r\n  };\r\n\r\n  return !this.env.contains_(this.actual.argsForCall, expectedArgs);\r\n};\r\n\r\n/**\r\n * Matcher that checks that the expected item is an element in the actual Array.\r\n *\r\n * @param {Object} expected\r\n */\r\njasmine.Matchers.prototype.toContain = function(expected) {\r\n  return this.env.contains_(this.actual, expected);\r\n};\r\n\r\n/**\r\n * Matcher that checks that the expected item is NOT an element in the actual Array.\r\n *\r\n * @param {Object} expected\r\n * @deprecated as of 1.0. Use not.toContain() instead.\r\n */\r\njasmine.Matchers.prototype.toNotContain = function(expected) {\r\n  return !this.env.contains_(this.actual, expected);\r\n};\r\n\r\njasmine.Matchers.prototype.toBeLessThan = function(expected) {\r\n  return this.actual < expected;\r\n};\r\n\r\njasmine.Matchers.prototype.toBeGreaterThan = function(expected) {\r\n  return this.actual > expected;\r\n};\r\n\r\n/**\r\n * Matcher that checks that the expected item is equal to the actual item\r\n * up to a given level of decimal precision (default 2).\r\n *\r\n * @param {Number} expected\r\n * @param {Number} precision\r\n */\r\njasmine.Matchers.prototype.toBeCloseTo = function(expected, precision) {\r\n  if (!(precision === 0)) {\r\n    precision = precision || 2;\r\n  }\r\n  var multiplier = Math.pow(10, precision);\r\n  var actual = Math.round(this.actual * multiplier);\r\n  expected = Math.round(expected * multiplier);\r\n  return expected == actual;\r\n};\r\n\r\n/**\r\n * Matcher that checks that the expected exception was thrown by the actual.\r\n *\r\n * @param {String} expected\r\n */\r\njasmine.Matchers.prototype.toThrow = function(expected) {\r\n  var result = false;\r\n  var exception;\r\n  if (typeof this.actual != 'function') {\r\n    throw new Error('Actual is not a function');\r\n  }\r\n  try {\r\n    this.actual();\r\n  } catch (e) {\r\n    exception = e;\r\n  }\r\n  if (exception) {\r\n    result = (expected === jasmine.undefined || this.env.equals_(exception.message || exception, expected.message || expected));\r\n  }\r\n\r\n  var not = this.isNot ? \"not \" : \"\";\r\n\r\n  this.message = function() {\r\n    if (exception && (expected === jasmine.undefined || !this.env.equals_(exception.message || exception, expected.message || expected))) {\r\n      return [\"Expected function \" + not + \"to throw\", expected ? expected.message || expected : \"an exception\", \", but it threw\", exception.message || exception].join(' ');\r\n    } else {\r\n      return \"Expected function to throw an exception.\";\r\n    }\r\n  };\r\n\r\n  return result;\r\n};\r\n\r\njasmine.Matchers.Any = function(expectedClass) {\r\n  this.expectedClass = expectedClass;\r\n};\r\n\r\njasmine.Matchers.Any.prototype.jasmineMatches = function(other) {\r\n  if (this.expectedClass == String) {\r\n    return typeof other == 'string' || other instanceof String;\r\n  }\r\n\r\n  if (this.expectedClass == Number) {\r\n    return typeof other == 'number' || other instanceof Number;\r\n  }\r\n\r\n  if (this.expectedClass == Function) {\r\n    return typeof other == 'function' || other instanceof Function;\r\n  }\r\n\r\n  if (this.expectedClass == Object) {\r\n    return typeof other == 'object';\r\n  }\r\n\r\n  return other instanceof this.expectedClass;\r\n};\r\n\r\njasmine.Matchers.Any.prototype.jasmineToString = function() {\r\n  return '<jasmine.any(' + this.expectedClass + ')>';\r\n};\r\n\r\njasmine.Matchers.ObjectContaining = function (sample) {\r\n  this.sample = sample;\r\n};\r\n\r\njasmine.Matchers.ObjectContaining.prototype.jasmineMatches = function(other, mismatchKeys, mismatchValues) {\r\n  mismatchKeys = mismatchKeys || [];\r\n  mismatchValues = mismatchValues || [];\r\n\r\n  var env = jasmine.getEnv();\r\n\r\n  var hasKey = function(obj, keyName) {\r\n    return obj != null && obj[keyName] !== jasmine.undefined;\r\n  };\r\n\r\n  for (var property in this.sample) {\r\n    if (!hasKey(other, property) && hasKey(this.sample, property)) {\r\n      mismatchKeys.push(\"expected has key '\" + property + \"', but missing from actual.\");\r\n    }\r\n    else if (!env.equals_(this.sample[property], other[property], mismatchKeys, mismatchValues)) {\r\n      mismatchValues.push(\"'\" + property + \"' was '\" + (other[property] ? jasmine.util.htmlEscape(other[property].toString()) : other[property]) + \"' in expected, but was '\" + (this.sample[property] ? jasmine.util.htmlEscape(this.sample[property].toString()) : this.sample[property]) + \"' in actual.\");\r\n    }\r\n  }\r\n\r\n  return (mismatchKeys.length === 0 && mismatchValues.length === 0);\r\n};\r\n\r\njasmine.Matchers.ObjectContaining.prototype.jasmineToString = function () {\r\n  return \"<jasmine.objectContaining(\" + jasmine.pp(this.sample) + \")>\";\r\n};\r\n// Mock setTimeout, clearTimeout\r\n// Contributed by Pivotal Computer Systems, www.pivotalsf.com\r\n\r\njasmine.FakeTimer = function() {\r\n  this.reset();\r\n\r\n  var self = this;\r\n  self.setTimeout = function(funcToCall, millis) {\r\n    self.timeoutsMade++;\r\n    self.scheduleFunction(self.timeoutsMade, funcToCall, millis, false);\r\n    return self.timeoutsMade;\r\n  };\r\n\r\n  self.setInterval = function(funcToCall, millis) {\r\n    self.timeoutsMade++;\r\n    self.scheduleFunction(self.timeoutsMade, funcToCall, millis, true);\r\n    return self.timeoutsMade;\r\n  };\r\n\r\n  self.clearTimeout = function(timeoutKey) {\r\n    self.scheduledFunctions[timeoutKey] = jasmine.undefined;\r\n  };\r\n\r\n  self.clearInterval = function(timeoutKey) {\r\n    self.scheduledFunctions[timeoutKey] = jasmine.undefined;\r\n  };\r\n\r\n};\r\n\r\njasmine.FakeTimer.prototype.reset = function() {\r\n  this.timeoutsMade = 0;\r\n  this.scheduledFunctions = {};\r\n  this.nowMillis = 0;\r\n};\r\n\r\njasmine.FakeTimer.prototype.tick = function(millis) {\r\n  var oldMillis = this.nowMillis;\r\n  var newMillis = oldMillis + millis;\r\n  this.runFunctionsWithinRange(oldMillis, newMillis);\r\n  this.nowMillis = newMillis;\r\n};\r\n\r\njasmine.FakeTimer.prototype.runFunctionsWithinRange = function(oldMillis, nowMillis) {\r\n  var scheduledFunc;\r\n  var funcsToRun = [];\r\n  for (var timeoutKey in this.scheduledFunctions) {\r\n    scheduledFunc = this.scheduledFunctions[timeoutKey];\r\n    if (scheduledFunc != jasmine.undefined &&\r\n        scheduledFunc.runAtMillis >= oldMillis &&\r\n        scheduledFunc.runAtMillis <= nowMillis) {\r\n      funcsToRun.push(scheduledFunc);\r\n      this.scheduledFunctions[timeoutKey] = jasmine.undefined;\r\n    }\r\n  }\r\n\r\n  if (funcsToRun.length > 0) {\r\n    funcsToRun.sort(function(a, b) {\r\n      return a.runAtMillis - b.runAtMillis;\r\n    });\r\n    for (var i = 0; i < funcsToRun.length; ++i) {\r\n      try {\r\n        var funcToRun = funcsToRun[i];\r\n        this.nowMillis = funcToRun.runAtMillis;\r\n        funcToRun.funcToCall();\r\n        if (funcToRun.recurring) {\r\n          this.scheduleFunction(funcToRun.timeoutKey,\r\n              funcToRun.funcToCall,\r\n              funcToRun.millis,\r\n              true);\r\n        }\r\n      } catch(e) {\r\n      }\r\n    }\r\n    this.runFunctionsWithinRange(oldMillis, nowMillis);\r\n  }\r\n};\r\n\r\njasmine.FakeTimer.prototype.scheduleFunction = function(timeoutKey, funcToCall, millis, recurring) {\r\n  this.scheduledFunctions[timeoutKey] = {\r\n    runAtMillis: this.nowMillis + millis,\r\n    funcToCall: funcToCall,\r\n    recurring: recurring,\r\n    timeoutKey: timeoutKey,\r\n    millis: millis\r\n  };\r\n};\r\n\r\n/**\r\n * @namespace\r\n */\r\njasmine.Clock = {\r\n  defaultFakeTimer: new jasmine.FakeTimer(),\r\n\r\n  reset: function() {\r\n    jasmine.Clock.assertInstalled();\r\n    jasmine.Clock.defaultFakeTimer.reset();\r\n  },\r\n\r\n  tick: function(millis) {\r\n    jasmine.Clock.assertInstalled();\r\n    jasmine.Clock.defaultFakeTimer.tick(millis);\r\n  },\r\n\r\n  runFunctionsWithinRange: function(oldMillis, nowMillis) {\r\n    jasmine.Clock.defaultFakeTimer.runFunctionsWithinRange(oldMillis, nowMillis);\r\n  },\r\n\r\n  scheduleFunction: function(timeoutKey, funcToCall, millis, recurring) {\r\n    jasmine.Clock.defaultFakeTimer.scheduleFunction(timeoutKey, funcToCall, millis, recurring);\r\n  },\r\n\r\n  useMock: function() {\r\n    if (!jasmine.Clock.isInstalled()) {\r\n      var spec = jasmine.getEnv().currentSpec;\r\n      spec.after(jasmine.Clock.uninstallMock);\r\n\r\n      jasmine.Clock.installMock();\r\n    }\r\n  },\r\n\r\n  installMock: function() {\r\n    jasmine.Clock.installed = jasmine.Clock.defaultFakeTimer;\r\n  },\r\n\r\n  uninstallMock: function() {\r\n    jasmine.Clock.assertInstalled();\r\n    jasmine.Clock.installed = jasmine.Clock.real;\r\n  },\r\n\r\n  real: {\r\n    setTimeout: jasmine.getGlobal().setTimeout,\r\n    clearTimeout: jasmine.getGlobal().clearTimeout,\r\n    setInterval: jasmine.getGlobal().setInterval,\r\n    clearInterval: jasmine.getGlobal().clearInterval\r\n  },\r\n\r\n  assertInstalled: function() {\r\n    if (!jasmine.Clock.isInstalled()) {\r\n      throw new Error(\"Mock clock is not installed, use jasmine.Clock.useMock()\");\r\n    }\r\n  },\r\n\r\n  isInstalled: function() {\r\n    return jasmine.Clock.installed == jasmine.Clock.defaultFakeTimer;\r\n  },\r\n\r\n  installed: null\r\n};\r\njasmine.Clock.installed = jasmine.Clock.real;\r\n\r\n//else for IE support\r\njasmine.getGlobal().setTimeout = function(funcToCall, millis) {\r\n  if (jasmine.Clock.installed.setTimeout.apply) {\r\n    return jasmine.Clock.installed.setTimeout.apply(this, arguments);\r\n  } else {\r\n    return jasmine.Clock.installed.setTimeout(funcToCall, millis);\r\n  }\r\n};\r\n\r\njasmine.getGlobal().setInterval = function(funcToCall, millis) {\r\n  if (jasmine.Clock.installed.setInterval.apply) {\r\n    return jasmine.Clock.installed.setInterval.apply(this, arguments);\r\n  } else {\r\n    return jasmine.Clock.installed.setInterval(funcToCall, millis);\r\n  }\r\n};\r\n\r\njasmine.getGlobal().clearTimeout = function(timeoutKey) {\r\n  if (jasmine.Clock.installed.clearTimeout.apply) {\r\n    return jasmine.Clock.installed.clearTimeout.apply(this, arguments);\r\n  } else {\r\n    return jasmine.Clock.installed.clearTimeout(timeoutKey);\r\n  }\r\n};\r\n\r\njasmine.getGlobal().clearInterval = function(timeoutKey) {\r\n  if (jasmine.Clock.installed.clearTimeout.apply) {\r\n    return jasmine.Clock.installed.clearInterval.apply(this, arguments);\r\n  } else {\r\n    return jasmine.Clock.installed.clearInterval(timeoutKey);\r\n  }\r\n};\r\n\r\n/**\r\n * @constructor\r\n */\r\njasmine.MultiReporter = function() {\r\n  this.subReporters_ = [];\r\n};\r\njasmine.util.inherit(jasmine.MultiReporter, jasmine.Reporter);\r\n\r\njasmine.MultiReporter.prototype.addReporter = function(reporter) {\r\n  this.subReporters_.push(reporter);\r\n};\r\n\r\n(function() {\r\n  var functionNames = [\r\n    \"reportRunnerStarting\",\r\n    \"reportRunnerResults\",\r\n    \"reportSuiteResults\",\r\n    \"reportSpecStarting\",\r\n    \"reportSpecResults\",\r\n    \"log\"\r\n  ];\r\n  for (var i = 0; i < functionNames.length; i++) {\r\n    var functionName = functionNames[i];\r\n    jasmine.MultiReporter.prototype[functionName] = (function(functionName) {\r\n      return function() {\r\n        for (var j = 0; j < this.subReporters_.length; j++) {\r\n          var subReporter = this.subReporters_[j];\r\n          if (subReporter[functionName]) {\r\n            subReporter[functionName].apply(subReporter, arguments);\r\n          }\r\n        }\r\n      };\r\n    })(functionName);\r\n  }\r\n})();\r\n/**\r\n * Holds results for a set of Jasmine spec. Allows for the results array to hold another jasmine.NestedResults\r\n *\r\n * @constructor\r\n */\r\njasmine.NestedResults = function() {\r\n  /**\r\n   * The total count of results\r\n   */\r\n  this.totalCount = 0;\r\n  /**\r\n   * Number of passed results\r\n   */\r\n  this.passedCount = 0;\r\n  /**\r\n   * Number of failed results\r\n   */\r\n  this.failedCount = 0;\r\n  /**\r\n   * Was this suite/spec skipped?\r\n   */\r\n  this.skipped = false;\r\n  /**\r\n   * @ignore\r\n   */\r\n  this.items_ = [];\r\n};\r\n\r\n/**\r\n * Roll up the result counts.\r\n *\r\n * @param result\r\n */\r\njasmine.NestedResults.prototype.rollupCounts = function(result) {\r\n  this.totalCount += result.totalCount;\r\n  this.passedCount += result.passedCount;\r\n  this.failedCount += result.failedCount;\r\n};\r\n\r\n/**\r\n * Adds a log message.\r\n * @param values Array of message parts which will be concatenated later.\r\n */\r\njasmine.NestedResults.prototype.log = function(values) {\r\n  this.items_.push(new jasmine.MessageResult(values));\r\n};\r\n\r\n/**\r\n * Getter for the results: message & results.\r\n */\r\njasmine.NestedResults.prototype.getItems = function() {\r\n  return this.items_;\r\n};\r\n\r\n/**\r\n * Adds a result, tracking counts (total, passed, & failed)\r\n * @param {jasmine.ExpectationResult|jasmine.NestedResults} result\r\n */\r\njasmine.NestedResults.prototype.addResult = function(result) {\r\n  if (result.type != 'log') {\r\n    if (result.items_) {\r\n      this.rollupCounts(result);\r\n    } else {\r\n      this.totalCount++;\r\n      if (result.passed()) {\r\n        this.passedCount++;\r\n      } else {\r\n        this.failedCount++;\r\n      }\r\n    }\r\n  }\r\n  this.items_.push(result);\r\n};\r\n\r\n/**\r\n * @returns {Boolean} True if <b>everything</b> below passed\r\n */\r\njasmine.NestedResults.prototype.passed = function() {\r\n  return this.passedCount === this.totalCount;\r\n};\r\n/**\r\n * Base class for pretty printing for expectation results.\r\n */\r\njasmine.PrettyPrinter = function() {\r\n  this.ppNestLevel_ = 0;\r\n};\r\n\r\n/**\r\n * Formats a value in a nice, human-readable string.\r\n *\r\n * @param value\r\n */\r\njasmine.PrettyPrinter.prototype.format = function(value) {\r\n  if (this.ppNestLevel_ > 40) {\r\n    throw new Error('jasmine.PrettyPrinter: format() nested too deeply!');\r\n  }\r\n\r\n  this.ppNestLevel_++;\r\n  try {\r\n    if (value === jasmine.undefined) {\r\n      this.emitScalar('undefined');\r\n    } else if (value === null) {\r\n      this.emitScalar('null');\r\n    } else if (value === jasmine.getGlobal()) {\r\n      this.emitScalar('<global>');\r\n    } else if (value.jasmineToString) {\r\n      this.emitScalar(value.jasmineToString());\r\n    } else if (typeof value === 'string') {\r\n      this.emitString(value);\r\n    } else if (jasmine.isSpy(value)) {\r\n      this.emitScalar(\"spy on \" + value.identity);\r\n    } else if (value instanceof RegExp) {\r\n      this.emitScalar(value.toString());\r\n    } else if (typeof value === 'function') {\r\n      this.emitScalar('Function');\r\n    } else if (typeof value.nodeType === 'number') {\r\n      this.emitScalar('HTMLNode');\r\n    } else if (value instanceof Date) {\r\n      this.emitScalar('Date(' + value + ')');\r\n    } else if (value.__Jasmine_been_here_before__) {\r\n      this.emitScalar('<circular reference: ' + (jasmine.isArray_(value) ? 'Array' : 'Object') + '>');\r\n    } else if (jasmine.isArray_(value) || typeof value == 'object') {\r\n      value.__Jasmine_been_here_before__ = true;\r\n      if (jasmine.isArray_(value)) {\r\n        this.emitArray(value);\r\n      } else {\r\n        this.emitObject(value);\r\n      }\r\n      delete value.__Jasmine_been_here_before__;\r\n    } else {\r\n      this.emitScalar(value.toString());\r\n    }\r\n  } finally {\r\n    this.ppNestLevel_--;\r\n  }\r\n};\r\n\r\njasmine.PrettyPrinter.prototype.iterateObject = function(obj, fn) {\r\n  for (var property in obj) {\r\n    if (property == '__Jasmine_been_here_before__') continue;\r\n    fn(property, obj.__lookupGetter__ ? (obj.__lookupGetter__(property) !== jasmine.undefined && \r\n                                         obj.__lookupGetter__(property) !== null) : false);\r\n  }\r\n};\r\n\r\njasmine.PrettyPrinter.prototype.emitArray = jasmine.unimplementedMethod_;\r\njasmine.PrettyPrinter.prototype.emitObject = jasmine.unimplementedMethod_;\r\njasmine.PrettyPrinter.prototype.emitScalar = jasmine.unimplementedMethod_;\r\njasmine.PrettyPrinter.prototype.emitString = jasmine.unimplementedMethod_;\r\n\r\njasmine.StringPrettyPrinter = function() {\r\n  jasmine.PrettyPrinter.call(this);\r\n\r\n  this.string = '';\r\n};\r\njasmine.util.inherit(jasmine.StringPrettyPrinter, jasmine.PrettyPrinter);\r\n\r\njasmine.StringPrettyPrinter.prototype.emitScalar = function(value) {\r\n  this.append(value);\r\n};\r\n\r\njasmine.StringPrettyPrinter.prototype.emitString = function(value) {\r\n  this.append(\"'\" + value + \"'\");\r\n};\r\n\r\njasmine.StringPrettyPrinter.prototype.emitArray = function(array) {\r\n  this.append('[ ');\r\n  for (var i = 0; i < array.length; i++) {\r\n    if (i > 0) {\r\n      this.append(', ');\r\n    }\r\n    this.format(array[i]);\r\n  }\r\n  this.append(' ]');\r\n};\r\n\r\njasmine.StringPrettyPrinter.prototype.emitObject = function(obj) {\r\n  var self = this;\r\n  this.append('{ ');\r\n  var first = true;\r\n\r\n  this.iterateObject(obj, function(property, isGetter) {\r\n    if (first) {\r\n      first = false;\r\n    } else {\r\n      self.append(', ');\r\n    }\r\n\r\n    self.append(property);\r\n    self.append(' : ');\r\n    if (isGetter) {\r\n      self.append('<getter>');\r\n    } else {\r\n      self.format(obj[property]);\r\n    }\r\n  });\r\n\r\n  this.append(' }');\r\n};\r\n\r\njasmine.StringPrettyPrinter.prototype.append = function(value) {\r\n  this.string += value;\r\n};\r\njasmine.Queue = function(env) {\r\n  this.env = env;\r\n  this.blocks = [];\r\n  this.running = false;\r\n  this.index = 0;\r\n  this.offset = 0;\r\n  this.abort = false;\r\n};\r\n\r\njasmine.Queue.prototype.addBefore = function(block) {\r\n  this.blocks.unshift(block);\r\n};\r\n\r\njasmine.Queue.prototype.add = function(block) {\r\n  this.blocks.push(block);\r\n};\r\n\r\njasmine.Queue.prototype.insertNext = function(block) {\r\n  this.blocks.splice((this.index + this.offset + 1), 0, block);\r\n  this.offset++;\r\n};\r\n\r\njasmine.Queue.prototype.start = function(onComplete) {\r\n  this.running = true;\r\n  this.onComplete = onComplete;\r\n  this.next_();\r\n};\r\n\r\njasmine.Queue.prototype.isRunning = function() {\r\n  return this.running;\r\n};\r\n\r\njasmine.Queue.LOOP_DONT_RECURSE = true;\r\n\r\njasmine.Queue.prototype.next_ = function() {\r\n  var self = this;\r\n  var goAgain = true;\r\n\r\n  while (goAgain) {\r\n    goAgain = false;\r\n    \r\n    if (self.index < self.blocks.length && !this.abort) {\r\n      var calledSynchronously = true;\r\n      var completedSynchronously = false;\r\n\r\n      var onComplete = function () {\r\n        if (jasmine.Queue.LOOP_DONT_RECURSE && calledSynchronously) {\r\n          completedSynchronously = true;\r\n          return;\r\n        }\r\n\r\n        if (self.blocks[self.index].abort) {\r\n          self.abort = true;\r\n        }\r\n\r\n        self.offset = 0;\r\n        self.index++;\r\n\r\n        var now = new Date().getTime();\r\n        if (self.env.updateInterval && now - self.env.lastUpdate > self.env.updateInterval) {\r\n          self.env.lastUpdate = now;\r\n          self.env.setTimeout(function() {\r\n            self.next_();\r\n          }, 0);\r\n        } else {\r\n          if (jasmine.Queue.LOOP_DONT_RECURSE && completedSynchronously) {\r\n            goAgain = true;\r\n          } else {\r\n            self.next_();\r\n          }\r\n        }\r\n      };\r\n      self.blocks[self.index].execute(onComplete);\r\n\r\n      calledSynchronously = false;\r\n      if (completedSynchronously) {\r\n        onComplete();\r\n      }\r\n      \r\n    } else {\r\n      self.running = false;\r\n      if (self.onComplete) {\r\n        self.onComplete();\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\njasmine.Queue.prototype.results = function() {\r\n  var results = new jasmine.NestedResults();\r\n  for (var i = 0; i < this.blocks.length; i++) {\r\n    if (this.blocks[i].results) {\r\n      results.addResult(this.blocks[i].results());\r\n    }\r\n  }\r\n  return results;\r\n};\r\n\r\n\r\n/**\r\n * Runner\r\n *\r\n * @constructor\r\n * @param {jasmine.Env} env\r\n */\r\njasmine.Runner = function(env) {\r\n  var self = this;\r\n  self.env = env;\r\n  self.queue = new jasmine.Queue(env);\r\n  self.before_ = [];\r\n  self.after_ = [];\r\n  self.suites_ = [];\r\n};\r\n\r\njasmine.Runner.prototype.execute = function() {\r\n  var self = this;\r\n  if (self.env.reporter.reportRunnerStarting) {\r\n    self.env.reporter.reportRunnerStarting(this);\r\n  }\r\n  self.queue.start(function () {\r\n    self.finishCallback();\r\n  });\r\n};\r\n\r\njasmine.Runner.prototype.beforeEach = function(beforeEachFunction) {\r\n  beforeEachFunction.typeName = 'beforeEach';\r\n  this.before_.splice(0,0,beforeEachFunction);\r\n};\r\n\r\njasmine.Runner.prototype.afterEach = function(afterEachFunction) {\r\n  afterEachFunction.typeName = 'afterEach';\r\n  this.after_.splice(0,0,afterEachFunction);\r\n};\r\n\r\n\r\njasmine.Runner.prototype.finishCallback = function() {\r\n  this.env.reporter.reportRunnerResults(this);\r\n};\r\n\r\njasmine.Runner.prototype.addSuite = function(suite) {\r\n  this.suites_.push(suite);\r\n};\r\n\r\njasmine.Runner.prototype.add = function(block) {\r\n  if (block instanceof jasmine.Suite) {\r\n    this.addSuite(block);\r\n  }\r\n  this.queue.add(block);\r\n};\r\n\r\njasmine.Runner.prototype.specs = function () {\r\n  var suites = this.suites();\r\n  var specs = [];\r\n  for (var i = 0; i < suites.length; i++) {\r\n    specs = specs.concat(suites[i].specs());\r\n  }\r\n  return specs;\r\n};\r\n\r\njasmine.Runner.prototype.suites = function() {\r\n  return this.suites_;\r\n};\r\n\r\njasmine.Runner.prototype.topLevelSuites = function() {\r\n  var topLevelSuites = [];\r\n  for (var i = 0; i < this.suites_.length; i++) {\r\n    if (!this.suites_[i].parentSuite) {\r\n      topLevelSuites.push(this.suites_[i]);\r\n    }\r\n  }\r\n  return topLevelSuites;\r\n};\r\n\r\njasmine.Runner.prototype.results = function() {\r\n  return this.queue.results();\r\n};\r\n/**\r\n * Internal representation of a Jasmine specification, or test.\r\n *\r\n * @constructor\r\n * @param {jasmine.Env} env\r\n * @param {jasmine.Suite} suite\r\n * @param {String} description\r\n */\r\njasmine.Spec = function(env, suite, description) {\r\n  if (!env) {\r\n    throw new Error('jasmine.Env() required');\r\n  }\r\n  if (!suite) {\r\n    throw new Error('jasmine.Suite() required');\r\n  }\r\n  var spec = this;\r\n  spec.id = env.nextSpecId ? env.nextSpecId() : null;\r\n  spec.env = env;\r\n  spec.suite = suite;\r\n  spec.description = description;\r\n  spec.queue = new jasmine.Queue(env);\r\n\r\n  spec.afterCallbacks = [];\r\n  spec.spies_ = [];\r\n\r\n  spec.results_ = new jasmine.NestedResults();\r\n  spec.results_.description = description;\r\n  spec.matchersClass = null;\r\n};\r\n\r\njasmine.Spec.prototype.getFullName = function() {\r\n  return this.suite.getFullName() + ' ' + this.description + '.';\r\n};\r\n\r\n\r\njasmine.Spec.prototype.results = function() {\r\n  return this.results_;\r\n};\r\n\r\n/**\r\n * All parameters are pretty-printed and concatenated together, then written to the spec's output.\r\n *\r\n * Be careful not to leave calls to <code>jasmine.log</code> in production code.\r\n */\r\njasmine.Spec.prototype.log = function() {\r\n  return this.results_.log(arguments);\r\n};\r\n\r\njasmine.Spec.prototype.runs = function (func) {\r\n  var block = new jasmine.Block(this.env, func, this);\r\n  this.addToQueue(block);\r\n  return this;\r\n};\r\n\r\njasmine.Spec.prototype.addToQueue = function (block) {\r\n  if (this.queue.isRunning()) {\r\n    this.queue.insertNext(block);\r\n  } else {\r\n    this.queue.add(block);\r\n  }\r\n};\r\n\r\n/**\r\n * @param {jasmine.ExpectationResult} result\r\n */\r\njasmine.Spec.prototype.addMatcherResult = function(result) {\r\n  this.results_.addResult(result);\r\n};\r\n\r\njasmine.Spec.prototype.expect = function(actual) {\r\n  var positive = new (this.getMatchersClass_())(this.env, actual, this);\r\n  positive.not = new (this.getMatchersClass_())(this.env, actual, this, true);\r\n  return positive;\r\n};\r\n\r\n/**\r\n * Waits a fixed time period before moving to the next block.\r\n *\r\n * @deprecated Use waitsFor() instead\r\n * @param {Number} timeout milliseconds to wait\r\n */\r\njasmine.Spec.prototype.waits = function(timeout) {\r\n  var waitsFunc = new jasmine.WaitsBlock(this.env, timeout, this);\r\n  this.addToQueue(waitsFunc);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Waits for the latchFunction to return true before proceeding to the next block.\r\n *\r\n * @param {Function} latchFunction\r\n * @param {String} optional_timeoutMessage\r\n * @param {Number} optional_timeout\r\n */\r\njasmine.Spec.prototype.waitsFor = function(latchFunction, optional_timeoutMessage, optional_timeout) {\r\n  var latchFunction_ = null;\r\n  var optional_timeoutMessage_ = null;\r\n  var optional_timeout_ = null;\r\n\r\n  for (var i = 0; i < arguments.length; i++) {\r\n    var arg = arguments[i];\r\n    switch (typeof arg) {\r\n      case 'function':\r\n        latchFunction_ = arg;\r\n        break;\r\n      case 'string':\r\n        optional_timeoutMessage_ = arg;\r\n        break;\r\n      case 'number':\r\n        optional_timeout_ = arg;\r\n        break;\r\n    }\r\n  }\r\n\r\n  var waitsForFunc = new jasmine.WaitsForBlock(this.env, optional_timeout_, latchFunction_, optional_timeoutMessage_, this);\r\n  this.addToQueue(waitsForFunc);\r\n  return this;\r\n};\r\n\r\njasmine.Spec.prototype.fail = function (e) {\r\n  var expectationResult = new jasmine.ExpectationResult({\r\n    passed: false,\r\n    message: e ? jasmine.util.formatException(e) : 'Exception',\r\n    trace: { stack: e.stack }\r\n  });\r\n  this.results_.addResult(expectationResult);\r\n};\r\n\r\njasmine.Spec.prototype.getMatchersClass_ = function() {\r\n  return this.matchersClass || this.env.matchersClass;\r\n};\r\n\r\njasmine.Spec.prototype.addMatchers = function(matchersPrototype) {\r\n  var parent = this.getMatchersClass_();\r\n  var newMatchersClass = function() {\r\n    parent.apply(this, arguments);\r\n  };\r\n  jasmine.util.inherit(newMatchersClass, parent);\r\n  jasmine.Matchers.wrapInto_(matchersPrototype, newMatchersClass);\r\n  this.matchersClass = newMatchersClass;\r\n};\r\n\r\njasmine.Spec.prototype.finishCallback = function() {\r\n  this.env.reporter.reportSpecResults(this);\r\n};\r\n\r\njasmine.Spec.prototype.finish = function(onComplete) {\r\n  this.removeAllSpies();\r\n  this.finishCallback();\r\n  if (onComplete) {\r\n    onComplete();\r\n  }\r\n};\r\n\r\njasmine.Spec.prototype.after = function(doAfter) {\r\n  if (this.queue.isRunning()) {\r\n    this.queue.add(new jasmine.Block(this.env, doAfter, this));\r\n  } else {\r\n    this.afterCallbacks.unshift(doAfter);\r\n  }\r\n};\r\n\r\njasmine.Spec.prototype.execute = function(onComplete) {\r\n  var spec = this;\r\n  if (!spec.env.specFilter(spec)) {\r\n    spec.results_.skipped = true;\r\n    spec.finish(onComplete);\r\n    return;\r\n  }\r\n\r\n  this.env.reporter.reportSpecStarting(this);\r\n\r\n  spec.env.currentSpec = spec;\r\n\r\n  spec.addBeforesAndAftersToQueue();\r\n\r\n  spec.queue.start(function () {\r\n    spec.finish(onComplete);\r\n  });\r\n};\r\n\r\njasmine.Spec.prototype.addBeforesAndAftersToQueue = function() {\r\n  var runner = this.env.currentRunner();\r\n  var i;\r\n\r\n  for (var suite = this.suite; suite; suite = suite.parentSuite) {\r\n    for (i = 0; i < suite.before_.length; i++) {\r\n      this.queue.addBefore(new jasmine.Block(this.env, suite.before_[i], this));\r\n    }\r\n  }\r\n  for (i = 0; i < runner.before_.length; i++) {\r\n    this.queue.addBefore(new jasmine.Block(this.env, runner.before_[i], this));\r\n  }\r\n  for (i = 0; i < this.afterCallbacks.length; i++) {\r\n    this.queue.add(new jasmine.Block(this.env, this.afterCallbacks[i], this));\r\n  }\r\n  for (suite = this.suite; suite; suite = suite.parentSuite) {\r\n    for (i = 0; i < suite.after_.length; i++) {\r\n      this.queue.add(new jasmine.Block(this.env, suite.after_[i], this));\r\n    }\r\n  }\r\n  for (i = 0; i < runner.after_.length; i++) {\r\n    this.queue.add(new jasmine.Block(this.env, runner.after_[i], this));\r\n  }\r\n};\r\n\r\njasmine.Spec.prototype.explodes = function() {\r\n  throw 'explodes function should not have been called';\r\n};\r\n\r\njasmine.Spec.prototype.spyOn = function(obj, methodName, ignoreMethodDoesntExist) {\r\n  if (obj == jasmine.undefined) {\r\n    throw \"spyOn could not find an object to spy upon for \" + methodName + \"()\";\r\n  }\r\n\r\n  if (!ignoreMethodDoesntExist && obj[methodName] === jasmine.undefined) {\r\n    throw methodName + '() method does not exist';\r\n  }\r\n\r\n  if (!ignoreMethodDoesntExist && obj[methodName] && obj[methodName].isSpy) {\r\n    throw new Error(methodName + ' has already been spied upon');\r\n  }\r\n\r\n  var spyObj = jasmine.createSpy(methodName);\r\n\r\n  this.spies_.push(spyObj);\r\n  spyObj.baseObj = obj;\r\n  spyObj.methodName = methodName;\r\n  spyObj.originalValue = obj[methodName];\r\n\r\n  obj[methodName] = spyObj;\r\n\r\n  return spyObj;\r\n};\r\n\r\njasmine.Spec.prototype.removeAllSpies = function() {\r\n  for (var i = 0; i < this.spies_.length; i++) {\r\n    var spy = this.spies_[i];\r\n    spy.baseObj[spy.methodName] = spy.originalValue;\r\n  }\r\n  this.spies_ = [];\r\n};\r\n\r\n/**\r\n * Internal representation of a Jasmine suite.\r\n *\r\n * @constructor\r\n * @param {jasmine.Env} env\r\n * @param {String} description\r\n * @param {Function} specDefinitions\r\n * @param {jasmine.Suite} parentSuite\r\n */\r\njasmine.Suite = function(env, description, specDefinitions, parentSuite) {\r\n  var self = this;\r\n  self.id = env.nextSuiteId ? env.nextSuiteId() : null;\r\n  self.description = description;\r\n  self.queue = new jasmine.Queue(env);\r\n  self.parentSuite = parentSuite;\r\n  self.env = env;\r\n  self.before_ = [];\r\n  self.after_ = [];\r\n  self.children_ = [];\r\n  self.suites_ = [];\r\n  self.specs_ = [];\r\n};\r\n\r\njasmine.Suite.prototype.getFullName = function() {\r\n  var fullName = this.description;\r\n  for (var parentSuite = this.parentSuite; parentSuite; parentSuite = parentSuite.parentSuite) {\r\n    fullName = parentSuite.description + ' ' + fullName;\r\n  }\r\n  return fullName;\r\n};\r\n\r\njasmine.Suite.prototype.finish = function(onComplete) {\r\n  this.env.reporter.reportSuiteResults(this);\r\n  this.finished = true;\r\n  if (typeof(onComplete) == 'function') {\r\n    onComplete();\r\n  }\r\n};\r\n\r\njasmine.Suite.prototype.beforeEach = function(beforeEachFunction) {\r\n  beforeEachFunction.typeName = 'beforeEach';\r\n  this.before_.unshift(beforeEachFunction);\r\n};\r\n\r\njasmine.Suite.prototype.afterEach = function(afterEachFunction) {\r\n  afterEachFunction.typeName = 'afterEach';\r\n  this.after_.unshift(afterEachFunction);\r\n};\r\n\r\njasmine.Suite.prototype.results = function() {\r\n  return this.queue.results();\r\n};\r\n\r\njasmine.Suite.prototype.add = function(suiteOrSpec) {\r\n  this.children_.push(suiteOrSpec);\r\n  if (suiteOrSpec instanceof jasmine.Suite) {\r\n    this.suites_.push(suiteOrSpec);\r\n    this.env.currentRunner().addSuite(suiteOrSpec);\r\n  } else {\r\n    this.specs_.push(suiteOrSpec);\r\n  }\r\n  this.queue.add(suiteOrSpec);\r\n};\r\n\r\njasmine.Suite.prototype.specs = function() {\r\n  return this.specs_;\r\n};\r\n\r\njasmine.Suite.prototype.suites = function() {\r\n  return this.suites_;\r\n};\r\n\r\njasmine.Suite.prototype.children = function() {\r\n  return this.children_;\r\n};\r\n\r\njasmine.Suite.prototype.execute = function(onComplete) {\r\n  var self = this;\r\n  this.queue.start(function () {\r\n    self.finish(onComplete);\r\n  });\r\n};\r\njasmine.WaitsBlock = function(env, timeout, spec) {\r\n  this.timeout = timeout;\r\n  jasmine.Block.call(this, env, null, spec);\r\n};\r\n\r\njasmine.util.inherit(jasmine.WaitsBlock, jasmine.Block);\r\n\r\njasmine.WaitsBlock.prototype.execute = function (onComplete) {\r\n  if (jasmine.VERBOSE) {\r\n    this.env.reporter.log('>> Jasmine waiting for ' + this.timeout + ' ms...');\r\n  }\r\n  this.env.setTimeout(function () {\r\n    onComplete();\r\n  }, this.timeout);\r\n};\r\n/**\r\n * A block which waits for some condition to become true, with timeout.\r\n *\r\n * @constructor\r\n * @extends jasmine.Block\r\n * @param {jasmine.Env} env The Jasmine environment.\r\n * @param {Number} timeout The maximum time in milliseconds to wait for the condition to become true.\r\n * @param {Function} latchFunction A function which returns true when the desired condition has been met.\r\n * @param {String} message The message to display if the desired condition hasn't been met within the given time period.\r\n * @param {jasmine.Spec} spec The Jasmine spec.\r\n */\r\njasmine.WaitsForBlock = function(env, timeout, latchFunction, message, spec) {\r\n  this.timeout = timeout || env.defaultTimeoutInterval;\r\n  this.latchFunction = latchFunction;\r\n  this.message = message;\r\n  this.totalTimeSpentWaitingForLatch = 0;\r\n  jasmine.Block.call(this, env, null, spec);\r\n};\r\njasmine.util.inherit(jasmine.WaitsForBlock, jasmine.Block);\r\n\r\njasmine.WaitsForBlock.TIMEOUT_INCREMENT = 10;\r\n\r\njasmine.WaitsForBlock.prototype.execute = function(onComplete) {\r\n  if (jasmine.VERBOSE) {\r\n    this.env.reporter.log('>> Jasmine waiting for ' + (this.message || 'something to happen'));\r\n  }\r\n  var latchFunctionResult;\r\n  try {\r\n    latchFunctionResult = this.latchFunction.apply(this.spec);\r\n  } catch (e) {\r\n    this.spec.fail(e);\r\n    onComplete();\r\n    return;\r\n  }\r\n\r\n  if (latchFunctionResult) {\r\n    onComplete();\r\n  } else if (this.totalTimeSpentWaitingForLatch >= this.timeout) {\r\n    var message = 'timed out after ' + this.timeout + ' msec waiting for ' + (this.message || 'something to happen');\r\n    this.spec.fail({\r\n      name: 'timeout',\r\n      message: message\r\n    });\r\n\r\n    this.abort = true;\r\n    onComplete();\r\n  } else {\r\n    this.totalTimeSpentWaitingForLatch += jasmine.WaitsForBlock.TIMEOUT_INCREMENT;\r\n    var self = this;\r\n    this.env.setTimeout(function() {\r\n      self.execute(onComplete);\r\n    }, jasmine.WaitsForBlock.TIMEOUT_INCREMENT);\r\n  }\r\n};\r\n\r\njasmine.version_= {\r\n  \"major\": 1,\r\n  \"minor\": 2,\r\n  \"build\": 0,\r\n  \"revision\": 1337005947\r\n};\r\n"},34:function(a,b,c){c(1)(c(32))},35:function(a,b,c){c(1)(c(33))},36:function(a,b,c){c(2)(c(31))},37:function(a,b,c){c(35),c(34),c(36),c(38);var d=jasmine.getEnv(),e=new jasmine.HtmlReporter;d.addReporter(e),d.execute()},38:function(a,b,c){describe("TodoMVC features.",function(){var a=$.Event("keyup",{keyCode:13}),b="Foo Bar Todo";describe("Todo creation:",function(){beforeEach(function(){window.location.hash="#/"}),it("should allow creating a new todo",function(){runs(function(){$("#new-todo").val(b).trigger(a)}),waits(100),runs(function(){!!$("#todo-list li").text().match(b)})}),it("should not allow adding an empty todo",function(){var b,c=$("#todo-list li").length;runs(function(){$("#new-todo").val("   ").trigger(a)}),waits(100),runs(function(){expect($("#todo-list li").length).toEqual(c)})})}),describe("Todo completion:",function(){it("should allow marking a todo complete",function(){var c,d=$("#todo-list li.completed").length,e=" to be completed";runs(function(){$("#new-todo").val(b+e).trigger(a)}),waits(100),runs(function(){c=$("#todo-list li:last-child"),expect(c.text()).toMatch(e),c.find(".toggle").click(),expect($("#todo-list li.completed").length).toEqual(d+1)})}),it("should allow clearing completed todos",function(){var c,d=$("#todo-list li.completed").length,e=" to be completed";runs(function(){$("#new-todo").val(b+e).trigger(a)}),waits(100),runs(function(){c=$("#todo-list li:last-child"),expect(c.text()).toMatch(e),c.find(".toggle").click(),$("#clear-completed").click(),expect($("#todo-list li.completed").length).toEqual(0)})})}),describe("Todo deletion:",function(){it("should allow deleting a todo",function(){var c,d=$("#todo-list li").length,e=" to be deleted";runs(function(){$("#new-todo").val(b+e).trigger(a)}),waits(100),runs(function(){c=$("#todo-list li:last-child"),expect(c.text()).toMatch(e),c.find(".destroy").click(),expect($("#todo-list li").length).toEqual(d)})})})})}})